<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shop Reset Wizard - Comprehensive Merchandising Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0e1a;
            color: #e0e0e0;
            line-height: 1.6;
        }

        /* WIZARD CONTAINER */
        .wizard-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .wizard-header {
            text-align: center;
            padding: 40px 20px;
            border-bottom: 2px solid #667eea;
            margin-bottom: 40px;
        }

        .wizard-header h1 {
            font-size: 32px;
            color: #667eea;
            margin-bottom: 10px;
        }

        .wizard-header p {
            color: #94a3b8;
            font-size: 16px;
        }

        /* PROGRESS INDICATOR */
        .progress-bar {
            display: flex;
            justify-content: space-between;
            margin-bottom: 40px;
            padding: 0 20px;
        }

        .progress-step {
            flex: 1;
            text-align: center;
            position: relative;
        }

        .progress-step::before {
            content: '';
            position: absolute;
            top: 20px;
            left: 50%;
            right: -50%;
            height: 2px;
            background: #1e293b;
            z-index: 0;
        }

        .progress-step:last-child::before {
            display: none;
        }

        .progress-step.active::before {
            background: #667eea;
        }

        .progress-step.completed::before {
            background: #22c55e;
        }

        .progress-circle {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #1e293b;
            border: 2px solid #334155;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 10px;
            position: relative;
            z-index: 1;
            font-weight: bold;
        }

        .progress-step.active .progress-circle {
            background: #667eea;
            border-color: #667eea;
            color: white;
        }

        .progress-step.completed .progress-circle {
            background: #22c55e;
            border-color: #22c55e;
            color: white;
        }

        .progress-label {
            font-size: 12px;
            color: #64748b;
        }

        .progress-step.active .progress-label {
            color: #667eea;
            font-weight: 600;
        }

        /* WIZARD STEPS */
        .wizard-step {
            display: none;
            background: #12161f;
            border: 1px solid #1e293b;
            border-radius: 12px;
            padding: 40px;
            min-height: 500px;
        }

        .wizard-step.active {
            display: block;
        }

        .step-title {
            font-size: 24px;
            color: #667eea;
            margin-bottom: 10px;
        }

        .step-subtitle {
            color: #94a3b8;
            margin-bottom: 30px;
            font-size: 14px;
        }

        /* FORM ELEMENTS */
        .form-group {
            margin-bottom: 24px;
        }

        .form-label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: #94a3b8;
            margin-bottom: 8px;
        }

        .form-input {
            width: 100%;
            padding: 12px;
            background: #0a0e1a;
            border: 1px solid #1e293b;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .form-input:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea.form-input {
            min-height: 200px;
            font-family: monospace;
            resize: vertical;
        }

        .form-select {
            width: 100%;
            padding: 12px;
            background: #0a0e1a;
            border: 1px solid #1e293b;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 14px;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            font-size: 14px;
            color: #e0e0e0;
            cursor: pointer;
        }

        .checkbox-label input {
            margin-right: 10px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .radio-label {
            display: flex;
            align-items: flex-start;
            padding: 16px;
            background: #0a0e1a;
            border: 2px solid #1e293b;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .radio-label:hover {
            border-color: #667eea;
        }

        .radio-label input {
            margin-right: 12px;
            margin-top: 2px;
            cursor: pointer;
        }

        .radio-label.selected {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }

        .radio-content {
            flex: 1;
        }

        .radio-title {
            font-weight: 600;
            color: #e0e0e0;
            margin-bottom: 4px;
        }

        .radio-description {
            font-size: 13px;
            color: #94a3b8;
        }

        /* TEMPLATE CARDS */
        .template-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .template-card {
            background: #0a0e1a;
            border: 2px solid #1e293b;
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .template-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .template-card.selected {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }

        .template-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .template-name {
            font-size: 18px;
            font-weight: 600;
            color: #e0e0e0;
            margin-bottom: 8px;
        }

        .template-description {
            font-size: 13px;
            color: #94a3b8;
            margin-bottom: 12px;
        }

        .template-specs {
            font-size: 12px;
            color: #64748b;
        }

        /* DATA PREVIEW TABLE */
        .data-preview {
            background: #0a0e1a;
            border: 1px solid #1e293b;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 24px;
            max-height: 400px;
            overflow-y: auto;
        }

        .preview-table {
            width: 100%;
            border-collapse: collapse;
        }

        .preview-table th {
            background: #1e293b;
            padding: 10px;
            text-align: left;
            font-size: 12px;
            color: #94a3b8;
            font-weight: 600;
            position: sticky;
            top: 0;
        }

        .preview-table td {
            padding: 10px;
            border-bottom: 1px solid #1e293b;
            font-size: 13px;
        }

        .preview-table td input {
            width: 100%;
            background: transparent;
            border: 1px solid transparent;
            padding: 4px;
            color: #e0e0e0;
        }

        .preview-table td input:focus {
            outline: none;
            border-color: #667eea;
            background: #12161f;
        }

        /* BUTTONS */
        .wizard-actions {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
            padding-top: 30px;
            border-top: 1px solid #1e293b;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
        }

        .btn-secondary {
            background: #1e293b;
            color: #e0e0e0;
        }

        .btn-secondary:hover {
            background: #334155;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* INFO BOX */
        .info-box {
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid #667eea;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 24px;
        }

        .info-box-title {
            font-weight: 600;
            color: #667eea;
            margin-bottom: 8px;
        }

        .info-box-content {
            font-size: 13px;
            color: #94a3b8;
            line-height: 1.6;
        }

        /* ALERT */
        .alert {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 16px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            z-index: 1000;
            display: none;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .alert.show {
            display: block;
            animation: slideIn 0.3s ease-out;
        }

        .alert.success {
            background: #22c55e;
            color: white;
        }

        .alert.error {
            background: #ef4444;
            color: white;
        }

        .alert.info {
            background: #667eea;
            color: white;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* LOADING SPINNER */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 26, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .loading-overlay.show {
            display: flex;
        }

        .spinner {
            border: 4px solid #1e293b;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 20px;
            color: #94a3b8;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div id="alertBox" class="alert"></div>
    <div id="loadingOverlay" class="loading-overlay">
        <div style="text-align: center;">
            <div class="spinner"></div>
            <div class="loading-text" id="loadingText">Processing...</div>
        </div>
    </div>

    <div class="wizard-container">
        <div class="wizard-header">
            <h1>Shop Reset Wizard</h1>
            <p>Professional Merchandising Tool - From Data to Comprehensive Reset Packet in Minutes</p>
        </div>

        <!-- PROGRESS BAR -->
        <div class="progress-bar">
            <div class="progress-step active" data-step="1">
                <div class="progress-circle">1</div>
                <div class="progress-label">Project Setup</div>
            </div>
            <div class="progress-step" data-step="2">
                <div class="progress-circle">2</div>
                <div class="progress-label">Product Data</div>
            </div>
            <div class="progress-step" data-step="3">
                <div class="progress-circle">3</div>
                <div class="progress-label">Store Layout</div>
            </div>
            <div class="progress-step" data-step="4">
                <div class="progress-circle">4</div>
                <div class="progress-label">Goals & Rules</div>
            </div>
            <div class="progress-step" data-step="5">
                <div class="progress-circle">5</div>
                <div class="progress-label">Generate & Download</div>
            </div>
        </div>

        <!-- STEP 1: PROJECT SETUP -->
        <div class="wizard-step active" id="step1">
            <h2 class="step-title">Step 1: Project Setup</h2>
            <p class="step-subtitle">Basic information about your reset project</p>

            <div class="form-group">
                <label class="form-label">Project Name *</label>
                <input type="text" class="form-input" id="projectName" placeholder="e.g., Winter 2025 Reset">
            </div>

            <div class="form-group">
                <label class="form-label">Store Name/Location *</label>
                <input type="text" class="form-input" id="storeName" placeholder="e.g., Main Street Location">
            </div>

            <div class="form-group">
                <label class="form-label">Reset Type</label>
                <select class="form-select" id="resetType">
                    <option value="seasonal">Seasonal Change (e.g., Winter → Spring)</option>
                    <option value="clearance">Clearance/Markdown Event</option>
                    <option value="new-merchandise">New Merchandise Arrival</option>
                    <option value="promotion">Promotional Reset</option>
                    <option value="complete">Complete Store Refresh</option>
                </select>
            </div>

            <div class="wizard-actions">
                <button class="btn btn-secondary" disabled>Previous</button>
                <button class="btn btn-primary" onclick="nextStep(1)">Next: Product Data →</button>
            </div>
        </div>

        <!-- STEP 2: PRODUCT DATA -->
        <div class="wizard-step" id="step2">
            <h2 class="step-title">Step 2: Product Data</h2>
            <p class="step-subtitle">Paste your product list in any format - we'll parse it intelligently</p>

            <div class="info-box">
                <div class="info-box-title">Accepted Formats:</div>
                <div class="info-box-content">
                    • CSV or tab-separated (from Excel)<br>
                    • Simple list (one product per line)<br>
                    • Text with product info (we'll extract: name, price, category, etc.)<br>
                    • Mixed format - we'll do our best to parse it
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">Paste Product Data *</label>
                <textarea class="form-input" id="productDataInput" placeholder="Paste your product list here...

Examples:
Winter Coat, Outerwear, $199.99, 60%
Wool Scarf, Accessories, $29.99, 70%
Leather Boots, Footwear, $149.99, 55%

Or any other format you have..."></textarea>
            </div>

            <div style="display: flex; gap: 12px; margin-bottom: 24px;">
                <button class="btn btn-primary" onclick="parseProductData()">Parse Data & Preview</button>
                <button class="btn btn-secondary" onclick="vmTestData.loadTestData()" style="background: #667eea; color: white;">Load Test Data (50 Products)</button>
            </div>

            <div id="dataPreview" style="display: none;">
                <h3 style="margin-bottom: 16px; color: #94a3b8;">Parsed Data Preview (Edit if needed)</h3>
                <div class="data-preview">
                    <table class="preview-table" id="previewTable">
                        <thead>
                            <tr>
                                <th>Product Name</th>
                                <th>Category</th>
                                <th>Price</th>
                                <th>Margin %</th>
                                <th>Color</th>
                                <th>Style</th>
                                <th>Priority</th>
                            </tr>
                        </thead>
                        <tbody id="previewTableBody"></tbody>
                    </table>
                </div>
            </div>

            <div class="wizard-actions">
                <button class="btn btn-secondary" onclick="prevStep(2)">← Previous</button>
                <button class="btn btn-primary" onclick="nextStep(2)" id="step2NextBtn" disabled>Next: Store Layout →</button>
            </div>
        </div>

        <!-- STEP 3: STORE LAYOUT -->
        <div class="wizard-step" id="step3">
            <h2 class="step-title">Step 3: Store Layout Template</h2>
            <p class="step-subtitle">Choose a template that matches your store size and layout</p>

            <div class="template-grid">
                <div class="template-card" onclick="selectTemplate('small-boutique')">
                    <div class="template-icon">🏪</div>
                    <div class="template-name">Small Boutique</div>
                    <div class="template-description">Perfect for specialty stores and small retail spaces</div>
                    <div class="template-specs">
                        • 4 gondolas (2×2 grid)<br>
                        • 2 display tables<br>
                        • 1 feature display<br>
                        • 800"×600" default size
                    </div>
                </div>

                <div class="template-card" onclick="selectTemplate('medium-retail')">
                    <div class="template-icon">🏬</div>
                    <div class="template-name">Medium Retail</div>
                    <div class="template-description">Standard retail store layout</div>
                    <div class="template-specs">
                        • 8 gondolas (2×4 grid)<br>
                        • 4 display tables<br>
                        • 2 feature displays<br>
                        • 1200"×800" default size
                    </div>
                </div>

                <div class="template-card" onclick="selectTemplate('large-store')">
                    <div class="template-icon">🏢</div>
                    <div class="template-name">Large Store</div>
                    <div class="template-description">Big box retail or department store section</div>
                    <div class="template-specs">
                        • 16 gondolas (4×4 grid)<br>
                        • 6 display tables<br>
                        • 4 feature displays<br>
                        • 1600"×1200" default size
                    </div>
                </div>

                <div class="template-card" onclick="selectTemplate('grocery-layout')">
                    <div class="template-icon">🛒</div>
                    <div class="template-name">Grocery Layout</div>
                    <div class="template-description">Supermarket-style aisles with endcaps</div>
                    <div class="template-specs">
                        • 12 gondolas (3×4 grid)<br>
                        • 6 endcap displays<br>
                        • 2 checkout displays<br>
                        • 1400"×1000" default size
                    </div>
                </div>

                <div class="template-card" onclick="selectTemplate('custom')">
                    <div class="template-icon">⚙️</div>
                    <div class="template-name">Custom Layout</div>
                    <div class="template-description">Define your own fixtures and dimensions</div>
                    <div class="template-specs">
                        • Custom fixture count<br>
                        • Custom dimensions<br>
                        • Manual configuration<br>
                        • Full control
                    </div>
                </div>
            </div>

            <div id="customLayoutForm" style="display: none; background: #0a0e1a; padding: 24px; border-radius: 8px; border: 1px solid #1e293b; margin-top: 20px;">
                <h3 style="color: #94a3b8; margin-bottom: 20px;">Custom Layout Configuration</h3>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 24px;">
                    <div class="form-group">
                        <label class="form-label">Store Width (inches)</label>
                        <input type="text" class="form-input" id="customWidth" value="1200" onblur="calculateDimension(this)" placeholder="e.g., 5*24 or 3*48+2*36">
                        <div style="color: #64748b; font-size: 11px; margin-top: 4px;">
                            💡 Use as calculator: "5*24" = 120" or "3*48 + 2*36" = 216"
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Store Length (inches)</label>
                        <input type="text" class="form-input" id="customLength" value="800" onblur="calculateDimension(this)" placeholder="e.g., 4*24 or 10*12">
                        <div style="color: #64748b; font-size: 11px; margin-top: 4px;">
                            💡 Use as calculator: "4*24" = 96" or "6*12 + 18" = 90"
                        </div>
                    </div>
                </div>

                <h4 style="color: #667eea; margin-bottom: 16px;">Add Custom Fixture</h4>

                <div style="background: #12161f; border: 1px solid #1e293b; border-radius: 6px; padding: 20px; margin-bottom: 16px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                        <div class="form-group">
                            <label class="form-label">Fixture Name / ID</label>
                            <input type="text" class="form-input" id="fixtureName" placeholder="e.g., Main Wall Display, Slatwall-A, Rack-1">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Visual Type (for planogram)</label>
                            <select class="form-select" id="fixtureVisualType">
                                <option value="shelving">Shelving Unit (rectangle)</option>
                                <option value="wall">Wall Display (large rectangle)</option>
                                <option value="table">Table/Platform (circle)</option>
                                <option value="rack">Rack/Bar (oval)</option>
                                <option value="specialty">Specialty/Feature (diamond)</option>
                                <option value="counter">Counter/Register (wide rectangle)</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Width (inches)</label>
                            <input type="text" class="form-input" id="fixtureWidth" value="48" onblur="calculateDimension(this)" placeholder="e.g., 2*24 or 48">
                            <div style="color: #64748b; font-size: 11px; margin-top: 4px;">💡 Calculator: e.g., "2*24" = 48"</div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Height (inches)</label>
                            <input type="text" class="form-input" id="fixtureHeight" value="72" onblur="calculateDimension(this)" placeholder="e.g., 6*12 or 72">
                            <div style="color: #64748b; font-size: 11px; margin-top: 4px;">💡 Calculator: e.g., "6*12" = 72"</div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Depth (inches)</label>
                            <input type="text" class="form-input" id="fixtureDepth" value="18" onblur="calculateDimension(this)" placeholder="e.g., 1.5*12 or 18">
                            <div style="color: #64748b; font-size: 11px; margin-top: 4px;">💡 Calculator: e.g., "1.5*12" = 18"</div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Number of Levels/Shelves/Bars</label>
                            <input type="number" class="form-input" id="fixtureLevels" value="4" min="1" max="50" onchange="calculateFixtureCapacity()">
                            <div style="color: #64748b; font-size: 11px; margin-top: 4px;">Can be shelves, bars, sections, or any subdivision</div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Capacity Per Level</label>
                            <input type="number" class="form-input" id="fixtureCapacityPerLevel" value="10" min="1" max="200" onchange="calculateFixtureCapacity()">
                            <div style="color: #64748b; font-size: 11px; margin-top: 4px;">Number of items/products per level</div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Total Capacity</label>
                            <input type="number" class="form-input" id="fixtureTotalCapacity" value="40" readonly style="background: #0a0e1a; color: #64748b;">
                            <div style="color: #64748b; font-size: 11px; margin-top: 4px;">Auto-calculated: Levels × Capacity Per Level</div>
                        </div>
                    </div>

                    <div class="form-group" style="margin-top: 16px;">
                        <label class="form-label">Notes / Configuration Details (optional)</label>
                        <textarea class="form-input" id="fixtureNotes" placeholder="e.g., 'Slatwall with 8 horizontal bars, each bar holds 5 hardware packages' or 'Built-in wall shelving, 12 adjustable shelves'" style="min-height: 60px; resize: vertical;"></textarea>
                    </div>

                    <div style="display: flex; gap: 12px; margin-top: 16px;">
                        <button class="btn btn-primary" onclick="addCustomFixture()" style="flex: 1;">Add This Fixture</button>
                        <button class="btn btn-secondary" onclick="useFixtureTemplate()" style="flex: 1;">Load Template</button>
                        <button class="btn btn-secondary" onclick="clearFixtureForm()">Clear Form</button>
                    </div>
                </div>

                <div id="fixtureList" style="background: #12161f; border: 1px solid #1e293b; border-radius: 6px; padding: 16px; max-height: 300px; overflow-y: auto;">
                    <div style="color: #64748b; font-size: 14px; text-align: center; padding: 20px;">No fixtures added yet. Use the form above to add fixtures.</div>
                </div>
            </div>

            <input type="hidden" id="selectedTemplate" value="">

            <div class="wizard-actions">
                <button class="btn btn-secondary" onclick="prevStep(3)">← Previous</button>
                <button class="btn btn-primary" onclick="nextStep(3)" id="step3NextBtn" disabled>Next: Goals & Rules →</button>
            </div>
        </div>

        <!-- STEP 4: GOALS & RULES -->
        <div class="wizard-step" id="step4">
            <h2 class="step-title">Step 4: Merchandising Goals & Rules</h2>
            <p class="step-subtitle">Configure how products should be placed</p>

            <div class="form-group">
                <label class="form-label">Primary Objective *</label>
                <div class="radio-group">
                    <label class="radio-label">
                        <input type="radio" name="primaryGoal" value="maximize-profit" checked onchange="updateGoalWeights()">
                        <div class="radio-content">
                            <div class="radio-title">Maximize Profit Margin</div>
                            <div class="radio-description">Place highest-margin items in prime locations (eye-level, high-traffic zones)</div>
                        </div>
                    </label>
                    <label class="radio-label">
                        <input type="radio" name="primaryGoal" value="clear-inventory" onchange="updateGoalWeights()">
                        <div class="radio-content">
                            <div class="radio-title">Clear Old Inventory</div>
                            <div class="radio-description">Featured placement for slow-moving items to increase turnover</div>
                        </div>
                    </label>
                    <label class="radio-label">
                        <input type="radio" name="primaryGoal" value="feature-new" onchange="updateGoalWeights()">
                        <div class="radio-content">
                            <div class="radio-title">Feature New Arrivals</div>
                            <div class="radio-description">Prominently display new merchandise in entrance and high-traffic areas</div>
                        </div>
                    </label>
                    <label class="radio-label">
                        <input type="radio" name="primaryGoal" value="seasonal-theme" onchange="updateGoalWeights()">
                        <div class="radio-content">
                            <div class="radio-title">Seasonal Theming</div>
                            <div class="radio-description">Group seasonal items together for visual cohesion and customer convenience</div>
                        </div>
                    </label>
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">Merchandising Style</label>
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="colorBlocking" checked>
                        Color Blocking - Group similar colors together for visual impact
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="priceLaddering" checked>
                        Price Laddering - Show low/medium/high options within each category
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="completeLook">
                        Complete-the-Look - Outfit merchandising (tops with bottoms, accessories nearby)
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="brandBlocking">
                        Brand Blocking - Keep brands together (vs. mixing competitors)
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="crossSell" checked>
                        Cross-Sell Optimization - Place complementary items near each other
                    </label>
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">Safety & Constraints</label>
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="heavyBottom" checked>
                        Heavy items on bottom shelves (safety + restocking ease)
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="lossPrevention" checked>
                        High-value items near register/cameras (loss prevention)
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="fragileAwareness">
                        Fragile items away from high-traffic areas
                    </label>
                </div>
            </div>

            <div class="wizard-actions">
                <button class="btn btn-secondary" onclick="prevStep(4)">← Previous</button>
                <button class="btn btn-primary" onclick="nextStep(4)">Next: Generate Plan →</button>
            </div>
        </div>

        <!-- STEP 5: GENERATE -->
        <div class="wizard-step" id="step5">
            <h2 class="step-title">Step 5: Generate Reset Plan</h2>
            <p class="step-subtitle">Review configuration and generate your comprehensive reset packet</p>

            <div class="info-box">
                <div class="info-box-title">What You'll Get:</div>
                <div class="info-box-content">
                    ✓ Visual floor plan with product placements<br>
                    ✓ Product-by-product placement list (Gondola-X, Shelf-Y, Position-Z)<br>
                    ✓ Step-by-step execution checklist<br>
                    ✓ Printable shelf labels<br>
                    ✓ Product relationship guide explaining placement logic<br>
                    ✓ Executive summary with ROI projections<br>
                    <br>
                    All in one downloadable PDF packet ready for your team.
                </div>
            </div>

            <div id="configSummary" style="background: #0a0e1a; padding: 24px; border-radius: 8px; margin-bottom: 24px;">
                <h3 style="color: #94a3b8; margin-bottom: 16px;">Configuration Summary</h3>
                <div id="summaryContent" style="font-size: 14px; line-height: 1.8;"></div>
            </div>

            <button class="btn btn-primary" onclick="generateResetPlan()" style="width: 100%; padding: 16px; font-size: 16px; margin-bottom: 24px;">
                🚀 Generate Comprehensive Reset Plan
            </button>

            <div id="generationResults" style="display: none;">
                <h3 style="color: #22c55e; margin-bottom: 16px;">✓ Plan Generated Successfully!</h3>
                <div style="background: #0a0e1a; padding: 24px; border-radius: 8px; margin-bottom: 24px;">
                    <div id="resultsContent" style="font-size: 14px; line-height: 1.8;"></div>
                </div>
                <button class="btn btn-primary" onclick="downloadPacket()" style="width: 100%; padding: 16px; font-size: 16px;">
                    📥 Download Complete Reset Packet (PDF)
                </button>
            </div>

            <div class="wizard-actions">
                <button class="btn btn-secondary" onclick="prevStep(5)">← Previous</button>
                <button class="btn btn-secondary" onclick="resetWizard()">Start New Project</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script>
        // ==================== STATE MANAGEMENT ====================
        const wizardState = {
            currentStep: 1,
            projectName: '',
            storeName: '',
            resetType: 'seasonal',
            products: [],
            storeTemplate: null,
            templateConfig: {},
            primaryGoal: 'maximize-profit',
            merchandisingRules: {
                colorBlocking: true,
                priceLaddering: true,
                completeLook: false,
                brandBlocking: false,
                crossSell: true,
                heavyBottom: true,
                lossPrevention: true,
                fragileAwareness: false
            },
            generatedPlan: null
        };

        // ==================== WIZARD NAVIGATION ====================
        function nextStep(currentStep) {
            // Validation
            if (currentStep === 1) {
                const projectName = document.getElementById('projectName').value.trim();
                const storeName = document.getElementById('storeName').value.trim();
                if (!projectName || !storeName) {
                    showAlert('Please fill in all required fields', 'error');
                    return;
                }
                wizardState.projectName = projectName;
                wizardState.storeName = storeName;
                wizardState.resetType = document.getElementById('resetType').value;
            } else if (currentStep === 2) {
                if (wizardState.products.length === 0) {
                    showAlert('Please parse product data first', 'error');
                    return;
                }
            } else if (currentStep === 3) {
                if (!wizardState.storeTemplate) {
                    showAlert('Please select a store layout template', 'error');
                    return;
                }
            }

            // Mark current step as completed
            const currentStepEl = document.querySelector(`.progress-step[data-step="${currentStep}"]`);
            currentStepEl.classList.add('completed');
            currentStepEl.classList.remove('active');

            // Activate next step
            const nextStepNum = currentStep + 1;
            const nextStepEl = document.querySelector(`.progress-step[data-step="${nextStepNum}"]`);
            nextStepEl.classList.add('active');

            // Show/hide wizard steps
            document.querySelectorAll('.wizard-step').forEach(el => el.classList.remove('active'));
            document.getElementById(`step${nextStepNum}`).classList.add('active');

            wizardState.currentStep = nextStepNum;

            // Special handling for step 5 (summary)
            if (nextStepNum === 5) {
                showConfigurationSummary();
            }

            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function prevStep(currentStep) {
            const prevStepNum = currentStep - 1;

            // Update progress
            const currentStepEl = document.querySelector(`.progress-step[data-step="${currentStep}"]`);
            currentStepEl.classList.remove('active');

            const prevStepEl = document.querySelector(`.progress-step[data-step="${prevStepNum}"]`);
            prevStepEl.classList.add('active');
            prevStepEl.classList.remove('completed');

            // Show/hide wizard steps
            document.querySelectorAll('.wizard-step').forEach(el => el.classList.remove('active'));
            document.getElementById(`step${prevStepNum}`).classList.add('active');

            wizardState.currentStep = prevStepNum;

            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // ==================== PRODUCT DATA PARSING ====================
        function parseProductData() {
            const input = document.getElementById('productDataInput').value.trim();
            if (!input) {
                showAlert('Please paste product data first', 'error');
                return;
            }

            showLoading('Parsing product data...');

            setTimeout(() => {
                const products = smartParseProductData(input);
                wizardState.products = products;

                renderDataPreview(products);
                document.getElementById('dataPreview').style.display = 'block';
                document.getElementById('step2NextBtn').disabled = false;

                hideLoading();
                showAlert(`Parsed ${products.length} products successfully!`, 'success');
            }, 500);
        }

        function smartParseProductData(input) {
            const products = [];
            const lines = input.split('\n').filter(line => line.trim());

            lines.forEach((line, idx) => {
                // Try multiple parsing strategies
                let parsed = null;

                // Strategy 1: CSV format (Name, Category, Price, Margin)
                if (line.includes(',')) {
                    const parts = line.split(',').map(p => p.trim());
                    if (parts.length >= 2) {
                        parsed = {
                            name: parts[0] || `Product ${idx + 1}`,
                            category: parts[1] || detectCategory(parts[0]),
                            price: parsePrice(parts[2]) || 50,
                            margin: parseMargin(parts[3]) || 50,
                            color: detectColor(parts[0]) || '',
                            style: detectStyle(parts[0]) || 'casual',
                            priority: 'normal'
                        };
                    }
                }

                // Strategy 2: Tab-separated (Excel paste)
                if (!parsed && line.includes('\t')) {
                    const parts = line.split('\t').map(p => p.trim());
                    parsed = {
                        name: parts[0] || `Product ${idx + 1}`,
                        category: parts[1] || detectCategory(parts[0]),
                        price: parsePrice(parts[2]) || 50,
                        margin: parseMargin(parts[3]) || 50,
                        color: detectColor(parts[0]) || '',
                        style: detectStyle(parts[0]) || 'casual',
                        priority: 'normal'
                    };
                }

                // Strategy 3: Simple list (just product names)
                if (!parsed) {
                    parsed = {
                        name: line,
                        category: detectCategory(line),
                        price: 50,
                        margin: 50,
                        color: detectColor(line) || '',
                        style: detectStyle(line) || 'casual',
                        priority: 'normal'
                    };
                }

                if (parsed) {
                    parsed.id = idx + 1;
                    products.push(parsed);
                }
            });

            return products;
        }

        function parsePrice(str) {
            if (!str) return null;
            const match = str.match(/[\d.]+/);
            return match ? parseFloat(match[0]) : null;
        }

        function parseMargin(str) {
            if (!str) return null;
            const match = str.match(/[\d.]+/);
            return match ? parseFloat(match[0]) : null;
        }

        function detectCategory(name) {
            const nameLower = name.toLowerCase();
            if (nameLower.includes('jacket') || nameLower.includes('coat')) return 'Outerwear';
            if (nameLower.includes('scarf') || nameLower.includes('glove') || nameLower.includes('hat')) return 'Accessories';
            if (nameLower.includes('boot') || nameLower.includes('shoe') || nameLower.includes('sandal')) return 'Footwear';
            if (nameLower.includes('sweater') || nameLower.includes('shirt') || nameLower.includes('top')) return 'Tops';
            if (nameLower.includes('pant') || nameLower.includes('jean') || nameLower.includes('skirt')) return 'Bottoms';
            if (nameLower.includes('dress')) return 'Dresses';
            if (nameLower.includes('bag') || nameLower.includes('purse') || nameLower.includes('wallet')) return 'Bags';
            return 'General';
        }

        function detectColor(name) {
            const colors = ['red', 'blue', 'green', 'yellow', 'black', 'white', 'brown', 'gray', 'navy', 'beige', 'tan'];
            const nameLower = name.toLowerCase();
            for (const color of colors) {
                if (nameLower.includes(color)) return color;
            }
            return '';
        }

        function detectStyle(name) {
            const nameLower = name.toLowerCase();
            if (nameLower.includes('leather') || nameLower.includes('premium') || nameLower.includes('designer')) return 'premium';
            if (nameLower.includes('casual') || nameLower.includes('everyday')) return 'casual';
            if (nameLower.includes('formal') || nameLower.includes('dress')) return 'formal';
            if (nameLower.includes('sport') || nameLower.includes('athletic')) return 'athletic';
            return 'casual';
        }

        function renderDataPreview(products) {
            const tbody = document.getElementById('previewTableBody');
            tbody.innerHTML = '';

            products.forEach((product, idx) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td><input type="text" value="${product.name}" onchange="updateProduct(${idx}, 'name', this.value)"></td>
                    <td><input type="text" value="${product.category}" onchange="updateProduct(${idx}, 'category', this.value)"></td>
                    <td><input type="number" value="${product.price}" onchange="updateProduct(${idx}, 'price', this.value)"></td>
                    <td><input type="number" value="${product.margin}" onchange="updateProduct(${idx}, 'margin', this.value)"></td>
                    <td><input type="text" value="${product.color}" onchange="updateProduct(${idx}, 'color', this.value)"></td>
                    <td>
                        <select onchange="updateProduct(${idx}, 'style', this.value)">
                            <option value="casual" ${product.style === 'casual' ? 'selected' : ''}>Casual</option>
                            <option value="formal" ${product.style === 'formal' ? 'selected' : ''}>Formal</option>
                            <option value="athletic" ${product.style === 'athletic' ? 'selected' : ''}>Athletic</option>
                            <option value="premium" ${product.style === 'premium' ? 'selected' : ''}>Premium</option>
                        </select>
                    </td>
                    <td>
                        <select onchange="updateProduct(${idx}, 'priority', this.value)">
                            <option value="high" ${product.priority === 'high' ? 'selected' : ''}>High</option>
                            <option value="normal" ${product.priority === 'normal' ? 'selected' : ''}>Normal</option>
                            <option value="low" ${product.priority === 'low' ? 'selected' : ''}>Low</option>
                        </select>
                    </td>
                `;
                tbody.appendChild(row);
            });
        }

        function updateProduct(idx, field, value) {
            wizardState.products[idx][field] = value;
        }

        // ==================== STORE TEMPLATE SELECTION ====================
        function selectTemplate(templateId) {
            wizardState.storeTemplate = templateId;
            document.getElementById('selectedTemplate').value = templateId;

            // Update UI
            document.querySelectorAll('.template-card').forEach(card => {
                card.classList.remove('selected');
            });
            event.currentTarget.classList.add('selected');

            // Show/hide custom form
            if (templateId === 'custom') {
                document.getElementById('customLayoutForm').style.display = 'block';
            } else {
                document.getElementById('customLayoutForm').style.display = 'none';
            }

            // Store template config
            wizardState.templateConfig = getTemplateConfig(templateId);

            document.getElementById('step3NextBtn').disabled = false;
        }

        function getTemplateConfig(templateId) {
            const configs = {
                'small-boutique': {
                    width: 800,
                    length: 600,
                    gondolas: 4,
                    tables: 2,
                    displays: 1
                },
                'medium-retail': {
                    width: 1200,
                    length: 800,
                    gondolas: 8,
                    tables: 4,
                    displays: 2
                },
                'large-store': {
                    width: 1600,
                    length: 1200,
                    gondolas: 16,
                    tables: 6,
                    displays: 4
                },
                'grocery-layout': {
                    width: 1400,
                    length: 1000,
                    gondolas: 12,
                    tables: 2,
                    displays: 6
                },
                'custom': {
                    width: parseInt(document.getElementById('customWidth').value) || 1200,
                    length: parseInt(document.getElementById('customLength').value) || 800,
                    gondolas: parseInt(document.getElementById('customGondolas').value) || 8,
                    tables: parseInt(document.getElementById('customTables').value) || 4,
                    displays: parseInt(document.getElementById('customDisplays').value) || 2
                }
            };
            return configs[templateId];
        }

        // ==================== DIMENSION CALCULATOR ====================
        function calculateDimension(inputElement) {
            const originalValue = inputElement.value.trim();

            // If it's already a plain number, leave it
            if (/^\d+$/.test(originalValue)) {
                return;
            }

            // Safe math evaluation (only allows numbers, +, -, *, /, parentheses, and spaces)
            const sanitized = originalValue.replace(/[^0-9+\-*/()\s.]/g, '');

            if (sanitized !== originalValue) {
                showAlert('Invalid characters removed. Use only numbers and operators (+, -, *, /, parentheses)', 'warning');
            }

            try {
                // Create a safe function that only does math
                const result = Function('"use strict"; return (' + sanitized + ')')();

                if (isNaN(result) || !isFinite(result)) {
                    showAlert('Invalid calculation. Please check your math expression.', 'error');
                    return;
                }

                const rounded = Math.round(result);

                // Show what was calculated
                if (originalValue !== rounded.toString()) {
                    inputElement.value = rounded;
                    inputElement.style.borderColor = '#22c55e';
                    setTimeout(() => {
                        inputElement.style.borderColor = '';
                    }, 1500);

                    // Show calculation result
                    const label = inputElement.previousElementSibling;
                    const originalText = label.textContent;
                    label.textContent = `${originalText} (${originalValue} = ${rounded}")`;
                    label.style.color = '#22c55e';
                    setTimeout(() => {
                        label.textContent = originalText;
                        label.style.color = '';
                    }, 3000);
                }

            } catch (error) {
                showAlert('Could not calculate expression. Use format like: 5*24 or 3*48+2*36', 'error');
                console.error('Calculation error:', error);
            }
        }

        // ==================== CUSTOM FIXTURE MANAGEMENT ====================
        const customFixtures = [];

        // Calculate total fixture capacity automatically
        function calculateFixtureCapacity() {
            const levels = parseInt(document.getElementById('fixtureLevels').value) || 0;
            const capacityPerLevel = parseInt(document.getElementById('fixtureCapacityPerLevel').value) || 0;
            const totalCapacity = levels * capacityPerLevel;
            document.getElementById('fixtureTotalCapacity').value = totalCapacity;
        }

        // Add a fully custom fixture
        function addCustomFixture() {
            const name = document.getElementById('fixtureName').value.trim();
            const visualType = document.getElementById('fixtureVisualType').value;
            const width = parseInt(document.getElementById('fixtureWidth').value) || 48;
            const height = parseInt(document.getElementById('fixtureHeight').value) || 72;
            const depth = parseInt(document.getElementById('fixtureDepth').value) || 18;
            const levels = parseInt(document.getElementById('fixtureLevels').value) || 4;
            const capacityPerLevel = parseInt(document.getElementById('fixtureCapacityPerLevel').value) || 10;
            const totalCapacity = parseInt(document.getElementById('fixtureTotalCapacity').value) || 40;
            const notes = document.getElementById('fixtureNotes').value.trim();

            if (!name) {
                showAlert('Please enter a fixture name/ID', 'error');
                return;
            }

            const fixture = {
                id: Date.now(),
                name: name,
                type: visualType,
                width: width,
                height: height,
                depth: depth,
                levels: levels,
                capacityPerLevel: capacityPerLevel,
                capacity: totalCapacity,
                notes: notes
            };

            customFixtures.push(fixture);
            renderFixtureList();
            updateTemplateConfig();
            clearFixtureForm();
            showAlert(`Added fixture: ${name}`, 'success');
        }

        // Clear the fixture form
        function clearFixtureForm() {
            document.getElementById('fixtureName').value = '';
            document.getElementById('fixtureVisualType').value = 'shelving';
            document.getElementById('fixtureWidth').value = '48';
            document.getElementById('fixtureHeight').value = '72';
            document.getElementById('fixtureDepth').value = '18';
            document.getElementById('fixtureLevels').value = '4';
            document.getElementById('fixtureCapacityPerLevel').value = '10';
            document.getElementById('fixtureTotalCapacity').value = '40';
            document.getElementById('fixtureNotes').value = '';
        }

        // Load a fixture template
        function useFixtureTemplate() {
            const templates = {
                'Standard Gondola': { width: 48, height: 72, depth: 18, levels: 4, capPerLevel: 10, type: 'shelving' },
                'Large Slatwall': { width: 96, height: 96, depth: 4, levels: 8, capPerLevel: 12, type: 'wall' },
                'Clothing Rack with Bars': { width: 48, height: 72, depth: 24, levels: 2, capPerLevel: 15, type: 'rack' },
                'Wall Shelving': { width: 48, height: 84, depth: 12, levels: 6, capPerLevel: 8, type: 'wall' },
                'Display Table': { width: 48, height: 36, depth: 36, levels: 1, capPerLevel: 20, type: 'table' },
                'Counter/Register': { width: 72, height: 42, depth: 24, levels: 2, capPerLevel: 10, type: 'counter' }
            };

            const templateNames = Object.keys(templates);
            const selected = prompt('Choose a template:\n\n' + templateNames.map((n, i) => `${i + 1}. ${n}`).join('\n') + '\n\nEnter number (1-' + templateNames.length + '):');

            if (selected && !isNaN(selected)) {
                const index = parseInt(selected) - 1;
                if (index >= 0 && index < templateNames.length) {
                    const templateName = templateNames[index];
                    const template = templates[templateName];

                    document.getElementById('fixtureName').value = templateName;
                    document.getElementById('fixtureVisualType').value = template.type;
                    document.getElementById('fixtureWidth').value = template.width;
                    document.getElementById('fixtureHeight').value = template.height;
                    document.getElementById('fixtureDepth').value = template.depth;
                    document.getElementById('fixtureLevels').value = template.levels;
                    document.getElementById('fixtureCapacityPerLevel').value = template.capPerLevel;
                    calculateFixtureCapacity();
                    showAlert(`Loaded template: ${templateName}. Edit values as needed.`, 'info');
                }
            }
        }

        // Remove a fixture
        function removeFixture(id) {
            const index = customFixtures.findIndex(f => f.id === id);
            if (index > -1) {
                customFixtures.splice(index, 1);
                renderFixtureList();
                updateTemplateConfig();
                showAlert('Fixture removed', 'info');
            }
        }

        // Render the fixture list with full details
        function renderFixtureList() {
            const fixtureListDiv = document.getElementById('fixtureList');

            if (customFixtures.length === 0) {
                fixtureListDiv.innerHTML = '<div style="color: #64748b; font-size: 14px; text-align: center; padding: 20px;">No fixtures added yet. Use the form above to add fixtures.</div>';
                return;
            }

            let html = '';
            customFixtures.forEach((fixture, index) => {
                html += `
                    <div style="background: #0a0e1a; border: 1px solid #1e293b; border-radius: 6px; padding: 12px; margin-bottom: 12px;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                            <div style="flex: 1;">
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                    <span style="color: #e0e0e0; font-weight: 600; font-size: 15px;">${fixture.name}</span>
                                    <span style="background: #1e293b; color: #94a3b8; padding: 2px 8px; border-radius: 4px; font-size: 11px;">${fixture.type}</span>
                                </div>
                                <div style="display: grid; grid-template-columns: repeat(3, auto); gap-x: 16px; gap-y: 4px; color: #64748b; font-size: 12px;">
                                    <div><strong style="color: #94a3b8;">Dimensions:</strong> ${fixture.width}"W × ${fixture.height}"H × ${fixture.depth}"D</div>
                                    <div><strong style="color: #94a3b8;">Levels:</strong> ${fixture.levels}</div>
                                    <div><strong style="color: #94a3b8;">Per Level:</strong> ${fixture.capacityPerLevel} items</div>
                                    <div><strong style="color: #94a3b8;">Total Capacity:</strong> ${fixture.capacity} items</div>
                                </div>
                                ${fixture.notes ? `<div style="color: #64748b; font-size: 11px; margin-top: 6px; font-style: italic;">${fixture.notes}</div>` : ''}
                            </div>
                            <button class="btn btn-secondary" onclick="removeFixture(${fixture.id})" style="padding: 6px 12px; font-size: 12px; margin-left: 12px;">Remove</button>
                        </div>
                    </div>
                `;
            });

            // Add summary at bottom
            const totalFixtures = customFixtures.length;
            const totalCapacity = customFixtures.reduce((sum, f) => sum + f.capacity, 0);
            html += `
                <div style="background: rgba(102,126,234,0.1); border: 1px solid #667eea; border-radius: 6px; padding: 12px; margin-top: 16px;">
                    <div style="color: #667eea; font-weight: 600; margin-bottom: 4px;">Configuration Summary</div>
                    <div style="color: #94a3b8; font-size: 13px;">
                        ${totalFixtures} fixture${totalFixtures !== 1 ? 's' : ''} • ${totalCapacity} total item capacity
                    </div>
                </div>
            `;

            fixtureListDiv.innerHTML = html;
        }

        // Update template config with custom fixtures
        function updateTemplateConfig() {
            wizardState.templateConfig = {
                width: parseInt(document.getElementById('customWidth').value) || 1200,
                length: parseInt(document.getElementById('customLength').value) || 800,
                fixtures: customFixtures,
                gondolas: customFixtures.filter(f => f.type === 'shelving').length,
                tables: customFixtures.filter(f => f.type === 'table').length,
                displays: customFixtures.filter(f => f.type === 'specialty').length
            };
        }

        // ==================== GOALS & RULES ====================
        function updateGoalWeights() {
            const selectedGoal = document.querySelector('input[name="primaryGoal"]:checked').value;
            wizardState.primaryGoal = selectedGoal;

            // Update radio label styling
            document.querySelectorAll('.radio-label').forEach(label => {
                label.classList.remove('selected');
            });
            event.currentTarget.closest('.radio-label').classList.add('selected');
        }

        // ==================== CONFIGURATION SUMMARY ====================
        function showConfigurationSummary() {
            const summary = `
                <strong>Project:</strong> ${wizardState.projectName}<br>
                <strong>Store:</strong> ${wizardState.storeName}<br>
                <strong>Reset Type:</strong> ${wizardState.resetType}<br>
                <strong>Products:</strong> ${wizardState.products.length} items<br>
                <strong>Layout:</strong> ${wizardState.storeTemplate} (${wizardState.templateConfig.gondolas} gondolas, ${wizardState.templateConfig.tables} tables, ${wizardState.templateConfig.displays} displays)<br>
                <strong>Primary Goal:</strong> ${wizardState.primaryGoal}<br>
                <strong>Merchandising Rules:</strong> ${Object.entries(wizardState.merchandisingRules).filter(([k, v]) => v).map(([k]) => k).join(', ')}
            `;
            document.getElementById('summaryContent').innerHTML = summary;
        }

        // ==================== PLAN GENERATION ====================
        function generateResetPlan() {
            // Capture current merchandising rules
            wizardState.merchandisingRules = {
                colorBlocking: document.getElementById('colorBlocking').checked,
                priceLaddering: document.getElementById('priceLaddering').checked,
                completeLook: document.getElementById('completeLook').checked,
                brandBlocking: document.getElementById('brandBlocking').checked,
                crossSell: document.getElementById('crossSell').checked,
                heavyBottom: document.getElementById('heavyBottom').checked,
                lossPrevention: document.getElementById('lossPrevention').checked,
                fragileAwareness: document.getElementById('fragileAwareness').checked
            };

            showLoading('Generating comprehensive reset plan...');

            setTimeout(() => {
                const plan = runMultiFactorOptimization();
                wizardState.generatedPlan = plan;

                displayGenerationResults(plan);
                document.getElementById('generationResults').style.display = 'block';

                hideLoading();
                showAlert('Reset plan generated successfully!', 'success');
            }, 2000);
        }

        function runMultiFactorOptimization() {
            const products = wizardState.products;
            const config = wizardState.templateConfig;
            const rules = wizardState.merchandisingRules;

            // STEP 0: Initialize Visual Merchandising Features (CRITICAL for scoring)
            // Initialize traffic flow golden triangle
            trafficFlow.setPoints(
                { x: 10, y: 10 },
                { x: config.width / 2, y: config.length / 2 },
                { x: 10, y: config.length - 10 }
            );

            // Analyze price distribution for price tier balancing
            priceLadder.analyzePriceDistribution(products);

            // STEP 1: Build product relationship matrix
            const relationships = buildProductRelationships(products);

            // STEP 2: Create fixture slots with heat zones
            const fixtureSlots = generateFixtureSlots(config);

            // STEP 3: Calculate multi-factor scores for each product
            const scoredProducts = products.map(product => {
                const baseValue = product.price * (product.margin / 100);
                const urgency = calculateUrgencyScore(product);

                return {
                    ...product,
                    baseValue: baseValue,
                    urgencyScore: urgency,
                    totalScore: 0, // Will be calculated per slot
                    weight: estimateProductWeight(product),
                    isFragile: isFragileProduct(product),
                    isHighValue: baseValue > 100
                };
            });

            // STEP 4: Assign products to slots using sophisticated matching
            const placements = assignProductsToSlots(scoredProducts, fixtureSlots, relationships);

            // STEP 5: Calculate statistics and projections
            const stats = calculatePlanStatistics(placements, products, config);

            return {
                placements: placements,
                stats: stats,
                relationships: relationships
            };
        }

        // ==================== PRODUCT RELATIONSHIPS ====================
        function buildProductRelationships(products) {
            const relationships = [];

            for (let i = 0; i < products.length; i++) {
                for (let j = i + 1; j < products.length; j++) {
                    const product1 = products[i];
                    const product2 = products[j];

                    let relationshipScore = 0;
                    const reasons = [];

                    // Category affinity (same category = group together)
                    if (product1.category === product2.category) {
                        relationshipScore += 0.5;
                        reasons.push('same category');
                    }

                    // Complementary items (coat + scarf, shirt + pants)
                    if (areComplementary(product1, product2)) {
                        relationshipScore += 0.8;
                        reasons.push('complementary items');
                    }

                    // Color coordination (if color blocking enabled)
                    if (wizardState.merchandisingRules.colorBlocking && product1.color && product2.color) {
                        if (product1.color === product2.color) {
                            relationshipScore += 0.6;
                            reasons.push('matching colors');
                        }
                    }

                    // Style cohesion
                    if (product1.style === product2.style) {
                        relationshipScore += 0.4;
                        reasons.push('similar style');
                    }

                    // Price laddering (show price range)
                    if (wizardState.merchandisingRules.priceLaddering) {
                        const priceDiff = Math.abs(product1.price - product2.price);
                        if (priceDiff > 20 && priceDiff < 100 && product1.category === product2.category) {
                            relationshipScore += 0.3;
                            reasons.push('price ladder');
                        }
                    }

                    if (relationshipScore > 0.3) {
                        relationships.push({
                            product1: product1.id,
                            product2: product2.id,
                            score: relationshipScore,
                            reasons: reasons
                        });
                    }
                }
            }

            return relationships;
        }

        function areComplementary(product1, product2) {
            const complementaryPairs = [
                ['outerwear', 'accessories'],
                ['tops', 'bottoms'],
                ['footwear', 'accessories'],
                ['dresses', 'accessories'],
                ['bags', 'footwear']
            ];

            const cat1 = product1.category.toLowerCase();
            const cat2 = product2.category.toLowerCase();

            return complementaryPairs.some(pair =>
                (cat1.includes(pair[0]) && cat2.includes(pair[1])) ||
                (cat1.includes(pair[1]) && cat2.includes(pair[0]))
            );
        }

        // ==================== FIXTURE SLOT GENERATION ====================
        function generateFixtureSlots(config) {
            const slots = [];
            let slotId = 1;

            // Gondolas (4 shelves each, with heat zones)
            for (let g = 1; g <= config.gondolas; g++) {
                const zone = determineStoreZone(g, config.gondolas);
                const zoneMultiplier = getZoneMultiplier(zone);

                // Shelf 4 (top) - 50% heat
                slots.push(createSlot(slotId++, 'gondola', g, 4, 'Top', 0.5, zone, zoneMultiplier));

                // Shelf 3 (eye level) - 90% heat
                slots.push(createSlot(slotId++, 'gondola', g, 3, 'Eye Level', 0.9, zone, zoneMultiplier));

                // Shelf 2 (mid) - 70% heat
                slots.push(createSlot(slotId++, 'gondola', g, 2, 'Mid', 0.7, zone, zoneMultiplier));

                // Shelf 1 (bottom) - 30% heat
                slots.push(createSlot(slotId++, 'gondola', g, 1, 'Bottom', 0.3, zone, zoneMultiplier));
            }

            // Tables (front/center/back zones)
            for (let t = 1; t <= config.tables; t++) {
                const zone = t <= config.tables / 2 ? 'entrance' : 'high-traffic';
                const zoneMultiplier = getZoneMultiplier(zone);

                slots.push(createSlot(slotId++, 'table', t, 1, 'Front', 0.9, zone, zoneMultiplier));
                slots.push(createSlot(slotId++, 'table', t, 1, 'Center', 0.6, zone, zoneMultiplier));
                slots.push(createSlot(slotId++, 'table', t, 1, 'Back', 0.3, zone, zoneMultiplier));
            }

            // Display cases (premium positioning)
            for (let d = 1; d <= config.displays; d++) {
                const zone = 'entrance';
                const zoneMultiplier = getZoneMultiplier(zone);

                slots.push(createSlot(slotId++, 'display', d, 1, 'Center', 1.0, zone, zoneMultiplier));
            }

            return slots;
        }

        function createSlot(id, fixtureType, fixtureNum, shelf, position, heatScore, zone, zoneMultiplier) {
            return {
                id: id,
                fixtureType: fixtureType,
                fixtureNum: fixtureNum,
                shelf: shelf,
                position: position,
                heatScore: heatScore,
                zone: zone,
                zoneMultiplier: zoneMultiplier,
                combinedScore: heatScore * zoneMultiplier,
                assigned: null,
                nearbyProducts: []
            };
        }

        function determineStoreZone(fixtureNum, totalFixtures) {
            const ratio = fixtureNum / totalFixtures;
            if (ratio < 0.25) return 'entrance';
            if (ratio < 0.5) return 'high-traffic';
            if (ratio < 0.75) return 'mid-store';
            return 'checkout';
        }

        function getZoneMultiplier(zone) {
            const multipliers = {
                'entrance': 1.3,
                'high-traffic': 1.2,
                'mid-store': 1.0,
                'checkout': 1.1
            };
            return multipliers[zone] || 1.0;
        }

        // ==================== SCORING FUNCTIONS ====================
        function calculateUrgencyScore(product) {
            if (product.priority === 'high') return 2.0;
            if (product.priority === 'low') return 0.5;
            return 1.0;
        }

        function estimateProductWeight(product) {
            // Estimate based on category
            const category = product.category.toLowerCase();
            if (category.includes('boot') || category.includes('shoe')) return 'heavy';
            if (category.includes('bag') || category.includes('purse')) return 'medium';
            if (category.includes('accessor') || category.includes('scarf')) return 'light';
            if (category.includes('coat') || category.includes('jacket')) return 'medium';
            return 'medium';
        }

        function isFragileProduct(product) {
            const name = product.name.toLowerCase();
            const category = product.category.toLowerCase();
            return name.includes('glass') || name.includes('crystal') ||
                   category.includes('jewelry') || category.includes('electronics');
        }

        function calculateSlotScore(product, slot, nearbyProducts, relationships) {
            let score = 0;
            const weights = getGoalWeights();

            // FACTOR 1: Product value × Heat zone × Store zone
            const valueScore = product.baseValue * slot.combinedScore;
            score += valueScore * weights.value;

            // FACTOR 2: Urgency/priority
            score += product.urgencyScore * 20 * weights.urgency;

            // FACTOR 3: Visual cohesion (color/style match with nearby)
            if (wizardState.merchandisingRules.colorBlocking && nearbyProducts.length > 0) {
                const colorMatch = nearbyProducts.filter(p => p.color === product.color).length / nearbyProducts.length;
                score += colorMatch * 15 * weights.visualCohesion;
            }

            // FACTOR 4: Cross-sell potential (complementary items nearby)
            if (wizardState.merchandisingRules.crossSell && nearbyProducts.length > 0) {
                const complementaryNearby = nearbyProducts.filter(p =>
                    relationships.some(r =>
                        (r.product1 === product.id && r.product2 === p.id) ||
                        (r.product2 === product.id && r.product1 === p.id)
                    )
                ).length;
                score += complementaryNearby * 25 * weights.crossSell;
            }

            // FACTOR 5: Category grouping
            const categoryMatch = nearbyProducts.filter(p => p.category === product.category).length;
            score += categoryMatch * 10 * weights.categoryFit;

            // FACTOR 6: Safety constraints (heavy items on bottom)
            if (wizardState.merchandisingRules.heavyBottom && product.weight === 'heavy') {
                if (slot.shelf === 1) score += 30; // Reward bottom shelf
                else if (slot.shelf >= 3) score -= 50; // Penalize top shelves
            }

            // FACTOR 7: Loss prevention (high-value near checkout/entrance)
            if (wizardState.merchandisingRules.lossPrevention && product.isHighValue) {
                if (slot.zone === 'checkout' || slot.zone === 'entrance') {
                    score += 20 * weights.lossPrevention;
                }
            }

            // FACTOR 8: Fragile item safety
            if (wizardState.merchandisingRules.fragileAwareness && product.isFragile) {
                if (slot.zone !== 'high-traffic' && slot.shelf <= 3) {
                    score += 15;
                }
            }

            // FACTOR 9: Premium positioning (premium items need space/premium fixtures)
            if (product.style === 'premium') {
                if (slot.fixtureType === 'display') score += 40;
                else if (slot.fixtureType === 'table') score += 20;
            }

            // FACTOR 10: Traffic Flow Path Proximity (VM Feature - 30% weight in unified scoring)
            // Calculate fixture location based on slot number and type
            const config = wizardState.templateConfig;
            if (config && trafficFlow.focalPoint) {
                const fixtureLocation = {
                    x: ((slot.fixtureNum - 1) % 4) * (config.width / 4) + (config.width / 8),
                    y: Math.floor((slot.fixtureNum - 1) / 4) * (config.length / 4) + (config.length / 8)
                };
                const pathScore = trafficFlow.scoreProductByPath(product, fixtureLocation);

                // Add bonus for on-path placement (30% weight = 30 points)
                if (pathScore.category === 'on-path') {
                    score += 30;
                } else if (pathScore.category === 'near-path') {
                    score += 20;
                } else if (pathScore.category === 'off-path') {
                    score += 5;
                }

                // Penalty for decompression zone violations
                if (pathScore.category === 'decompression-violation') {
                    score -= 40;
                }
            }

            // FACTOR 11: Price Tier Balancing (VM Feature - 15% weight in unified scoring)
            // Ensure good distribution across price tiers by slightly favoring underrepresented tiers
            if (priceLadder && priceLadder.tiers) {
                const productTier = priceLadder.tiers.find(t =>
                    product.price >= t.min && product.price < t.max
                );
                if (productTier && productTier.products) {
                    // If this tier is underrepresented (< 10% of products), give bonus
                    const tierPercentage = (productTier.products.length / wizardState.products.length) * 100;
                    if (tierPercentage < 10) {
                        score += 15; // 15% weight = 15 points
                    } else if (tierPercentage < 15) {
                        score += 8;
                    }
                }
            }

            return score;
        }

        function getGoalWeights() {
            const goal = wizardState.primaryGoal;

            const weightPresets = {
                'maximize-profit': {
                    value: 0.35,
                    urgency: 0.15,
                    visualCohesion: 0.10,
                    crossSell: 0.15,
                    categoryFit: 0.10,
                    lossPrevention: 0.10,
                    other: 0.05
                },
                'clear-inventory': {
                    value: 0.15,
                    urgency: 0.45,
                    visualCohesion: 0.10,
                    crossSell: 0.10,
                    categoryFit: 0.10,
                    lossPrevention: 0.05,
                    other: 0.05
                },
                'feature-new': {
                    value: 0.20,
                    urgency: 0.40,
                    visualCohesion: 0.15,
                    crossSell: 0.10,
                    categoryFit: 0.05,
                    lossPrevention: 0.05,
                    other: 0.05
                },
                'seasonal-theme': {
                    value: 0.15,
                    urgency: 0.15,
                    visualCohesion: 0.30,
                    crossSell: 0.15,
                    categoryFit: 0.15,
                    lossPrevention: 0.05,
                    other: 0.05
                }
            };

            return weightPresets[goal] || weightPresets['maximize-profit'];
        }

        // ==================== PRODUCT-TO-SLOT ASSIGNMENT ====================
        function assignProductsToSlots(products, slots, relationships) {
            const placements = [];
            const availableSlots = [...slots];

            // Sort products by base priority
            products.sort((a, b) => {
                const scoreA = a.baseValue * a.urgencyScore;
                const scoreB = b.baseValue * b.urgencyScore;
                return scoreB - scoreA;
            });

            products.forEach(product => {
                let bestSlot = null;
                let bestScore = -Infinity;

                // Evaluate each available slot
                availableSlots.forEach(slot => {
                    // Get products already placed nearby
                    const nearbyProducts = getNearbyProducts(slot, placements, products);

                    // Calculate score for this product in this slot
                    const score = calculateSlotScore(product, slot, nearbyProducts, relationships);

                    if (score > bestScore) {
                        bestScore = score;
                        bestSlot = slot;
                    }
                });

                if (bestSlot) {
                    // Assign product to best slot
                    const placement = {
                        product: product.name,
                        productId: product.id,
                        fixtureType: bestSlot.fixtureType,
                        fixtureNum: bestSlot.fixtureNum,
                        fixture: `${capitalize(bestSlot.fixtureType)}-${bestSlot.fixtureNum}`,
                        shelf: bestSlot.shelf,
                        shelfName: bestSlot.position,
                        position: bestSlot.position,
                        zone: bestSlot.zone,
                        heatScore: bestSlot.heatScore,
                        placementScore: bestScore,
                        rationale: generateEnhancedRationale(product, bestSlot, bestScore)
                    };

                    placements.push(placement);

                    // Mark slot as used
                    bestSlot.assigned = product.id;

                    // Remove from available slots
                    const slotIndex = availableSlots.indexOf(bestSlot);
                    if (slotIndex > -1) {
                        availableSlots.splice(slotIndex, 1);
                    }
                }
            });

            return placements;
        }

        function getNearbyProducts(slot, placements, allProducts) {
            // Find products in adjacent shelves or same fixture
            const nearby = placements.filter(p => {
                if (p.fixtureType === slot.fixtureType && p.fixtureNum === slot.fixtureNum) {
                    // Same fixture, adjacent shelf
                    return Math.abs(p.shelf - slot.shelf) <= 1;
                }
                // Adjacent fixture numbers
                if (p.fixtureType === slot.fixtureType && Math.abs(p.fixtureNum - slot.fixtureNum) === 1) {
                    return true;
                }
                return false;
            });

            return nearby.map(p => allProducts.find(prod => prod.id === p.productId)).filter(Boolean);
        }

        function generateEnhancedRationale(product, slot, score) {
            const reasons = [];

            if (slot.heatScore >= 0.8) {
                reasons.push('Premium visibility zone (90% heat)');
            } else if (slot.heatScore >= 0.6) {
                reasons.push('High-visibility placement (70% heat)');
            }

            if (slot.zone === 'entrance') {
                reasons.push('Entrance zone for first impressions');
            } else if (slot.zone === 'checkout') {
                reasons.push('Checkout zone for impulse purchases');
            }

            if (product.baseValue > 100) {
                reasons.push('High-value item');
            }

            if (product.priority === 'high') {
                reasons.push('Priority product');
            }

            if (product.style === 'premium' && slot.fixtureType === 'display') {
                reasons.push('Premium item on feature display');
            }

            if (product.weight === 'heavy' && slot.shelf === 1) {
                reasons.push('Heavy item on bottom shelf (safety)');
            }

            return reasons.join('; ') || 'Standard placement';
        }

        function capitalize(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        // ==================== STATISTICS CALCULATION ====================
        function calculatePlanStatistics(placements, products, config) {
            const totalValue = products.reduce((sum, p) => sum + p.price * (p.margin / 100), 0);
            const averageHeat = placements.reduce((sum, p) => sum + p.heatScore, 0) / placements.length;
            const premiumPlacements = placements.filter(p => p.heatScore >= 0.7).length;

            return {
                totalProducts: products.length,
                productsPlaced: placements.length,
                fixturesUsed: config.gondolas + config.tables + config.displays,
                estimatedTime: Math.ceil(products.length * 2 / 60), // 2 min per product
                projectedLift: calculateProjectedLift(averageHeat, premiumPlacements, products.length),
                averageHeatScore: Math.round(averageHeat * 100) + '%',
                premiumPlacements: premiumPlacements,
                totalValue: Math.round(totalValue)
            };
        }

        function calculateProjectedLift(avgHeat, premiumCount, totalProducts) {
            // Simple heuristic: higher heat = higher lift
            const heatFactor = avgHeat * 100;
            const premiumRatio = (premiumCount / totalProducts) * 100;
            const liftMin = Math.round(heatFactor * 0.15 + premiumRatio * 0.1);
            const liftMax = Math.round(liftMin * 1.5);
            return `${liftMin}-${liftMax}%`;
        }

        // ==================== PLANOGRAM VISUALIZATION ====================
        function generatePlanogram(plan) {
            const config = wizardState.templateConfig;
            const scale = 0.5; // Scale factor for display
            const displayWidth = config.width * scale;
            const displayHeight = config.length * scale;

            let html = '<div style="background: #0a0e1a; padding: 24px; border-radius: 8px; margin: 20px 0;">';
            html += '<h3 style="color: #667eea; margin-bottom: 16px;">Visual Planogram with Heat Zones</h3>';

            // SVG Canvas
            html += `<svg width="${displayWidth}" height="${displayHeight}" style="background: #1e293b; border-radius: 8px; border: 1px solid #334155;">`;

            // Draw heat zones (entrance, high-traffic, mid-store, checkout)
            const zoneHeight = displayHeight / 4;

            // Entrance zone (top) - highest heat
            html += `<rect x="0" y="0" width="${displayWidth}" height="${zoneHeight}" fill="rgba(239,68,68,0.15)" stroke="none"/>`;
            html += `<text x="10" y="20" fill="#ef4444" font-size="12" font-weight="bold">ENTRANCE ZONE (High Heat)</text>`;

            // High-traffic zone
            html += `<rect x="0" y="${zoneHeight}" width="${displayWidth}" height="${zoneHeight}" fill="rgba(245,158,11,0.15)" stroke="none"/>`;
            html += `<text x="10" y="${zoneHeight + 20}" fill="#f59e0b" font-size="12" font-weight="bold">HIGH-TRAFFIC ZONE</text>`;

            // Mid-store zone
            html += `<rect x="0" y="${zoneHeight * 2}" width="${displayWidth}" height="${zoneHeight}" fill="rgba(59,130,246,0.15)" stroke="none"/>`;
            html += `<text x="10" y="${zoneHeight * 2 + 20}" fill="#3b82f6" font-size="12" font-weight="bold">MID-STORE ZONE</text>`;

            // Checkout zone (bottom)
            html += `<rect x="0" y="${zoneHeight * 3}" width="${displayWidth}" height="${zoneHeight}" fill="rgba(34,197,94,0.15)" stroke="none"/>`;
            html += `<text x="10" y="${zoneHeight * 3 + 20}" fill="#22c55e" font-size="12" font-weight="bold">CHECKOUT ZONE (Impulse Items)</text>`;

            // Draw fixtures
            const fixtures = config.fixtures || [];
            const fixturesPerRow = Math.ceil(Math.sqrt(fixtures.length || (config.gondolas + config.tables + config.displays)));
            const fixtureSpacingX = displayWidth / (fixturesPerRow + 1);
            const fixtureSpacingY = displayHeight / (Math.ceil(fixtures.length / fixturesPerRow) + 1);

            let fixtureIndex = 0;
            const totalFixtures = fixtures.length > 0 ? fixtures.length : (config.gondolas + config.tables + config.displays);

            for (let row = 0; row < Math.ceil(totalFixtures / fixturesPerRow); row++) {
                for (let col = 0; col < fixturesPerRow && fixtureIndex < totalFixtures; col++) {
                    const x = (col + 1) * fixtureSpacingX - 20;
                    const y = (row + 1) * fixtureSpacingY - 15;

                    const fixture = fixtures[fixtureIndex] || { type: 'gondola', name: 'Fixture' };

                    // Determine fixture color based on type
                    let fixtureColor = '#667eea';
                    let fixtureShape = 'rect';
                    let fixtureSizeW = 40;
                    let fixtureSizeH = 30;

                    switch (fixture.type) {
                        case 'gondola':
                        case 'wall-shelving':
                            fixtureColor = '#667eea';
                            break;
                        case 'display-table':
                        case 'feature-display':
                            fixtureColor = '#f59e0b';
                            fixtureShape = 'circle';
                            fixtureSizeW = 20;
                            break;
                        case 'mannequin':
                            fixtureColor = '#8b5cf6';
                            fixtureShape = 'circle';
                            fixtureSizeW = 15;
                            break;
                        case 'endcap':
                            fixtureColor = '#ec4899';
                            fixtureSizeW = 20;
                            break;
                        case 'counter':
                            fixtureColor = '#22c55e';
                            fixtureSizeH = 20;
                            break;
                        default:
                            fixtureColor = '#64748b';
                    }

                    // Draw fixture
                    if (fixtureShape === 'circle') {
                        html += `<circle cx="${x + fixtureSizeW/2}" cy="${y + fixtureSizeH/2}" r="${fixtureSizeW}" fill="${fixtureColor}" opacity="0.8" stroke="#e0e0e0" stroke-width="1"/>`;
                    } else {
                        html += `<rect x="${x}" y="${y}" width="${fixtureSizeW}" height="${fixtureSizeH}" fill="${fixtureColor}" opacity="0.8" stroke="#e0e0e0" stroke-width="1" rx="2"/>`;
                    }

                    // Label fixture
                    html += `<text x="${x + fixtureSizeW/2}" y="${y + fixtureSizeH + 12}" fill="#94a3b8" font-size="9" text-anchor="middle">${fixture.name || `F${fixtureIndex + 1}`}</text>`;

                    fixtureIndex++;
                }
            }

            // Draw entrance indicator
            html += `<path d="M ${displayWidth / 2 - 30} 10 L ${displayWidth / 2} 0 L ${displayWidth / 2 + 30} 10 Z" fill="#22c55e" opacity="0.8"/>`;
            html += `<text x="${displayWidth / 2}" y="35" fill="#22c55e" font-size="14" font-weight="bold" text-anchor="middle">ENTRANCE</text>`;

            // Draw golden triangle if traffic flow is set
            if (trafficFlow.focalPoint) {
                const entrance = { x: trafficFlow.entrance.x * scale, y: trafficFlow.entrance.y * scale };
                const focal = { x: trafficFlow.focalPoint.x * scale, y: trafficFlow.focalPoint.y * scale };
                const cashwrap = { x: trafficFlow.cashwrap.x * scale, y: trafficFlow.cashwrap.y * scale };

                html += `<path d="M ${entrance.x},${entrance.y} L ${focal.x},${focal.y} L ${cashwrap.x},${cashwrap.y} Z" fill="none" stroke="#667eea" stroke-width="2" stroke-dasharray="5,5" opacity="0.6"/>`;
            }

            html += `</svg>`;

            // Legend
            html += `<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-top: 16px;">`;
            html += `<div style="display: flex; align-items: center; gap: 8px;"><div style="width: 16px; height: 16px; background: #667eea; border-radius: 2px;"></div><span style="color: #94a3b8; font-size: 12px;">Gondola / Shelving</span></div>`;
            html += `<div style="display: flex; align-items: center; gap: 8px;"><div style="width: 16px; height: 16px; background: #f59e0b; border-radius: 50%;"></div><span style="color: #94a3b8; font-size: 12px;">Display / Table</span></div>`;
            html += `<div style="display: flex; align-items: center; gap: 8px;"><div style="width: 16px; height: 16px; background: #8b5cf6; border-radius: 50%;"></div><span style="color: #94a3b8; font-size: 12px;">Mannequin</span></div>`;
            html += `<div style="display: flex; align-items: center; gap: 8px;"><div style="width: 16px; height: 16px; background: #ec4899; border-radius: 2px;"></div><span style="color: #94a3b8; font-size: 12px;">Endcap</span></div>`;
            html += `<div style="display: flex; align-items: center; gap: 8px;"><div style="width: 16px; height: 16px; background: #22c55e; border-radius: 2px;"></div><span style="color: #94a3b8; font-size: 12px;">Counter / Register</span></div>`;
            html += `</div>`;

            html += '</div>';
            return html;
        }

        function displayGenerationResults(plan) {
            // Generate Visual Merchandising Insights
            const priceStats = priceLadder.analyzePriceDistribution(wizardState.products);
            const priceGaps = priceLadder.identifyGaps(priceStats);
            const priceHistogram = priceLadder.generateHistogramHTML(priceStats, priceGaps);

            // Setup traffic flow (default positions for demo)
            trafficFlow.setPoints(
                { x: 10, y: 10 },
                { x: wizardState.templateConfig.width / 2, y: wizardState.templateConfig.length / 2 },
                { x: 10, y: wizardState.templateConfig.length - 10 }
            );

            // Create fixture map for traffic analysis
            const fixtureMap = [];
            for (let i = 1; i <= wizardState.templateConfig.gondolas; i++) {
                fixtureMap.push({
                    name: `Gondola-${i}`,
                    location: {
                        x: (i % 4) * (wizardState.templateConfig.width / 4) + 50,
                        y: Math.floor(i / 4) * (wizardState.templateConfig.length / 4) + 50
                    },
                    averageProductValue: 75
                });
            }

            const trafficAnalysis = trafficFlow.analyzeAllFixtures(fixtureMap);
            const trafficViz = trafficFlow.generateVisualizationHTML(
                wizardState.templateConfig.width,
                wizardState.templateConfig.length,
                trafficAnalysis
            );

            // Generate planogram visualization
            const planogramViz = generatePlanogram(plan);

            const content = `
                <strong>Optimization Results:</strong><br>
                • Total Products Placed: ${plan.stats.totalProducts}<br>
                • Fixtures Utilized: ${plan.stats.fixturesUsed}<br>
                • Premium Placements (High Heat): ${plan.stats.premiumPlacements} (${Math.round(plan.stats.premiumPlacements / plan.stats.totalProducts * 100)}%)<br>
                • Average Heat Score: ${plan.stats.averageHeatScore}<br>
                • Estimated Execution Time: ${plan.stats.estimatedTime} hours<br>
                • Projected Revenue Lift: ${plan.stats.projectedLift}<br>
                • Total Product Value: $${plan.stats.totalValue.toLocaleString()}<br>
                • Product Relationships Detected: ${plan.relationships.length}<br>
                <br>

                ${planogramViz}

                <div style="background: rgba(102,126,234,0.1); border-left: 4px solid #667eea; padding: 16px; margin: 20px 0; border-radius: 8px;">
                    <h4 style="color: #667eea; margin-bottom: 8px;">🎯 Visual Merchandising Insights</h4>
                    <p style="color: #94a3b8; font-size: 14px; margin: 0;">Enhanced with Price Ladder Analysis and Traffic Flow Optimization</p>
                </div>

                ${priceHistogram}
                ${trafficViz}

                <br>
                <strong>Top 5 Premium Placements:</strong><br>
                ${plan.placements
                    .sort((a, b) => b.heatScore - a.heatScore)
                    .slice(0, 5)
                    .map((p, i) =>
                        `${i + 1}. <strong>${p.product}</strong> → ${p.fixture}, ${p.shelfName}<br>
                         &nbsp;&nbsp;&nbsp;<em style="color: #94a3b8;">Heat: ${Math.round(p.heatScore * 100)}% | Zone: ${p.zone} | ${p.rationale}</em>`
                    ).join('<br>')}
                <br><br>
                <strong>Sample Category Groupings:</strong><br>
                ${generateCategoryGroupingSummary(plan.placements).join('<br>')}
                <br><br>
                <strong>Complementary Product Pairings:</strong><br>
                ${plan.relationships.slice(0, 5).map((r, i) => {
                    const p1 = wizardState.products.find(p => p.id === r.product1);
                    const p2 = wizardState.products.find(p => p.id === r.product2);
                    return `${i + 1}. ${p1.name} + ${p2.name} <em style="color: #94a3b8;">(${r.reasons.join(', ')})</em>`;
                }).join('<br>')}
            `;
            document.getElementById('resultsContent').innerHTML = content;
        }

        function generateCategoryGroupingSummary(placements) {
            const fixtureGroups = {};
            placements.forEach(p => {
                const key = p.fixture;
                if (!fixtureGroups[key]) fixtureGroups[key] = [];
                fixtureGroups[key].push(p);
            });

            const summary = [];
            Object.entries(fixtureGroups).slice(0, 3).forEach(([fixture, products]) => {
                const categories = [...new Set(products.map(p => {
                    const prod = wizardState.products.find(pr => pr.name === p.product);
                    return prod ? prod.category : 'Unknown';
                }))];
                summary.push(`• ${fixture}: ${categories.join(', ')}`);
            });

            return summary.length > 0 ? summary : ['• No groupings detected'];
        }

        // ==================== PDF GENERATION ====================
        function downloadPacket() {
            showLoading('Generating comprehensive PDF packet...');

            setTimeout(() => {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                const plan = wizardState.generatedPlan;

                // ===== PAGE 1: COVER =====
                doc.setFontSize(26);
                doc.setFont(undefined, 'bold');
                doc.text(wizardState.projectName, 20, 40);

                doc.setFontSize(16);
                doc.setFont(undefined, 'normal');
                doc.text(`Store: ${wizardState.storeName}`, 20, 55);
                doc.text(`Reset Type: ${wizardState.resetType}`, 20, 65);
                doc.text(`Date: ${new Date().toLocaleDateString()}`, 20, 75);

                doc.setFontSize(10);
                doc.setTextColor(100);
                doc.text('Generated by Shop Reset Wizard', 20, 280);
                doc.setTextColor(0);

                // ===== PAGE 2: EXECUTIVE SUMMARY =====
                doc.addPage();
                doc.setFontSize(20);
                doc.setFont(undefined, 'bold');
                doc.text('Executive Summary', 20, 20);

                doc.setFontSize(11);
                doc.setFont(undefined, 'normal');
                let y = 35;
                doc.text(`Total Products Placed: ${plan.stats.totalProducts}`, 20, y);
                doc.text(`Fixtures Utilized: ${plan.stats.fixturesUsed}`, 20, y += 8);
                doc.text(`Premium Placements: ${plan.stats.premiumPlacements} (${Math.round(plan.stats.premiumPlacements / plan.stats.totalProducts * 100)}%)`, 20, y += 8);
                doc.text(`Average Heat Score: ${plan.stats.averageHeatScore}`, 20, y += 8);
                doc.text(`Total Product Value: $${plan.stats.totalValue.toLocaleString()}`, 20, y += 8);
                doc.text(`Estimated Execution Time: ${plan.stats.estimatedTime} hours`, 20, y += 8);
                doc.text(`Projected Revenue Lift: ${plan.stats.projectedLift}`, 20, y += 8);

                y += 15;
                doc.setFont(undefined, 'bold');
                doc.text('Merchandising Strategy:', 20, y);
                doc.setFont(undefined, 'normal');
                doc.text(`Primary Goal: ${wizardState.primaryGoal}`, 20, y += 8);
                const activeRules = Object.entries(wizardState.merchandisingRules)
                    .filter(([k, v]) => v)
                    .map(([k]) => k);
                doc.text(`Active Rules: ${activeRules.join(', ')}`, 20, y += 8);

                // ===== PAGE 3: ZONE-BY-ZONE BREAKDOWN =====
                doc.addPage();
                doc.setFontSize(18);
                doc.setFont(undefined, 'bold');
                doc.text('Zone-by-Zone Breakdown', 20, 20);

                doc.setFontSize(10);
                doc.setFont(undefined, 'normal');
                y = 30;

                const zones = ['entrance', 'high-traffic', 'mid-store', 'checkout'];
                zones.forEach(zone => {
                    const zonePlacements = plan.placements.filter(p => p.zone === zone);
                    if (zonePlacements.length === 0) return;

                    doc.setFont(undefined, 'bold');
                    doc.text(`${zone.toUpperCase()} (${zonePlacements.length} products)`, 20, y);
                    doc.setFont(undefined, 'normal');
                    y += 6;

                    zonePlacements.slice(0, 5).forEach((p, idx) => {
                        if (y > 270) {
                            doc.addPage();
                            y = 20;
                        }
                        doc.text(`  ${idx + 1}. ${p.product} - ${p.fixture}, ${p.shelfName}`, 22, y);
                        y += 5;
                    });

                    if (zonePlacements.length > 5) {
                        doc.text(`  ... and ${zonePlacements.length - 5} more`, 22, y);
                        y += 5;
                    }

                    y += 8;
                });

                // ===== PAGE 4+: COMPLETE PRODUCT PLACEMENTS =====
                doc.addPage();
                doc.setFontSize(18);
                doc.setFont(undefined, 'bold');
                doc.text('Complete Product Placement List', 20, 20);

                doc.setFontSize(8);
                doc.setFont(undefined, 'normal');
                y = 30;

                plan.placements.forEach((placement, idx) => {
                    if (y > 270) {
                        doc.addPage();
                        y = 20;
                    }
                    doc.setFont(undefined, 'bold');
                    doc.text(`${idx + 1}. ${placement.product}`, 20, y);
                    doc.setFont(undefined, 'normal');
                    doc.text(`   Location: ${placement.fixture}, Shelf ${placement.shelf} (${placement.shelfName})`, 20, y + 4);
                    doc.text(`   Zone: ${placement.zone} | Heat: ${Math.round(placement.heatScore * 100)}%`, 20, y + 8);
                    doc.text(`   ${placement.rationale}`, 20, y + 12);
                    y += 18;
                });

                // ===== EXECUTION CHECKLIST =====
                doc.addPage();
                doc.setFontSize(18);
                doc.setFont(undefined, 'bold');
                doc.text('Step-by-Step Execution Checklist', 20, 20);

                doc.setFontSize(10);
                doc.setFont(undefined, 'normal');
                y = 35;

                doc.text('Pre-Reset Preparation:', 20, y);
                y += 7;
                doc.text('[ ] Clear all fixtures scheduled for reset', 25, y);
                doc.text('[ ] Prepare product inventory', 25, y += 6);
                doc.text('[ ] Print shelf labels (see labels section)', 25, y += 6);
                doc.text('[ ] Gather necessary tools and supplies', 25, y += 6);

                y += 10;
                doc.text('Execution Steps (by fixture):', 20, y);
                y += 7;

                const fixtureGroups = {};
                plan.placements.forEach(p => {
                    if (!fixtureGroups[p.fixture]) fixtureGroups[p.fixture] = [];
                    fixtureGroups[p.fixture].push(p);
                });

                Object.entries(fixtureGroups).forEach(([fixture, products], idx) => {
                    if (y > 265) {
                        doc.addPage();
                        y = 20;
                    }
                    doc.setFont(undefined, 'bold');
                    doc.text(`${idx + 1}. ${fixture}`, 25, y);
                    doc.setFont(undefined, 'normal');
                    y += 5;

                    products.forEach((p, i) => {
                        if (y > 270) {
                            doc.addPage();
                            y = 20;
                        }
                        doc.text(`   [ ] Place ${p.product} on Shelf ${p.shelf}, ${p.position}`, 30, y);
                        y += 4;
                    });
                    y += 6;
                });

                // ===== PRODUCT RELATIONSHIPS =====
                if (plan.relationships.length > 0) {
                    doc.addPage();
                    doc.setFontSize(18);
                    doc.setFont(undefined, 'bold');
                    doc.text('Product Relationship Guide', 20, 20);

                    doc.setFontSize(10);
                    doc.setFont(undefined, 'normal');
                    doc.text('These products are placed near each other to drive cross-sell:', 20, 30);

                    y = 40;
                    plan.relationships.slice(0, 15).forEach((r, idx) => {
                        if (y > 270) {
                            doc.addPage();
                            y = 20;
                        }
                        const p1 = wizardState.products.find(p => p.id === r.product1);
                        const p2 = wizardState.products.find(p => p.id === r.product2);
                        if (p1 && p2) {
                            doc.text(`${idx + 1}. ${p1.name} + ${p2.name}`, 20, y);
                            doc.setFontSize(9);
                            doc.setTextColor(100);
                            doc.text(`   (${r.reasons.join(', ')})`, 20, y + 4);
                            doc.setTextColor(0);
                            doc.setFontSize(10);
                            y += 10;
                        }
                    });
                }

                // ===== SHELF LABELS (PLACEHOLDER) =====
                doc.addPage();
                doc.setFontSize(18);
                doc.setFont(undefined, 'bold');
                doc.text('Printable Shelf Labels', 20, 20);

                doc.setFontSize(10);
                doc.setFont(undefined, 'normal');
                doc.text('Cut along dotted lines. Attach to shelf edges.', 20, 30);

                y = 45;
                let labelX = 20;
                plan.placements.forEach((p, idx) => {
                    if (y > 260) {
                        doc.addPage();
                        y = 45;
                        labelX = 20;
                    }

                    // Simple label: Product name + location
                    doc.setDrawColor(200);
                    doc.setLineDash([2, 2]);
                    doc.rect(labelX, y, 85, 20);
                    doc.setLineDash([]);

                    doc.setFontSize(9);
                    doc.setFont(undefined, 'bold');
                    doc.text(p.product, labelX + 3, y + 6);
                    doc.setFont(undefined, 'normal');
                    doc.setFontSize(7);
                    doc.text(`${p.fixture} | Shelf ${p.shelf}`, labelX + 3, y + 11);
                    doc.text(`${p.zone}`, labelX + 3, y + 15);

                    labelX += 90;
                    if (labelX > 110) {
                        labelX = 20;
                        y += 25;
                    }
                });

                // Save PDF
                doc.save(`${wizardState.projectName.replace(/\s+/g, '-')}-Reset-Plan.pdf`);

                hideLoading();
                showAlert('Comprehensive PDF packet downloaded!', 'success');
            }, 1500);
        }

        // ==================== UTILITIES ====================
        function showAlert(message, type) {
            const alert = document.getElementById('alertBox');
            alert.textContent = message;
            alert.className = `alert ${type} show`;
            setTimeout(() => {
                alert.classList.remove('show');
            }, 3000);
        }

        function showLoading(message) {
            document.getElementById('loadingText').textContent = message;
            document.getElementById('loadingOverlay').classList.add('show');
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').classList.remove('show');
        }

        function resetWizard() {
            if (confirm('Are you sure you want to start a new project? All current data will be lost.')) {
                location.reload();
            }
        }

        // Initialize radio label styling and VM validation
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelector('input[name="primaryGoal"]:checked').closest('.radio-label').classList.add('selected');

            // Initialize Visual Merchandising validation
            vmTimeBank.startPhase('phase0');
            const phase0Result = runPhase0Validation();
            vmTimeBank.endPhase('phase0');

            if (phase0Result) {
                console.log('✓ Visual Merchandising features initialized successfully');
            } else {
                console.warn('⚠ Visual Merchandising initialization had warnings');
            }
        });

        // ==================== VISUAL MERCHANDISING INFRASTRUCTURE (PHASE 0) ====================

        // VALIDATION FRAMEWORK
        const vmValidation = {
            errors: [],
            warnings: [],
            checkpoints: [],

            assertVM(condition, message, severity = 'error') {
                if (!condition) {
                    const record = { message, severity, timestamp: Date.now() };
                    if (severity === 'error') {
                        this.errors.push(record);
                    } else {
                        this.warnings.push(record);
                    }
                    return false;
                }
                return true;
            },

            runChecks(checks) {
                const results = [];
                checks.forEach(check => {
                    try {
                        const passed = check.fn();
                        results.push({ name: check.name, passed, error: null });
                        this.checkpoints.push({ name: check.name, passed, timestamp: Date.now() });
                    } catch (error) {
                        results.push({ name: check.name, passed: false, error: error.message });
                        this.errors.push({ message: `Check failed: ${check.name}`, severity: 'error', error });
                    }
                });
                return results;
            },

            validateFunction(fn, testCases) {
                const results = testCases.map(test => {
                    try {
                        const result = fn(...test.input);
                        const passed = JSON.stringify(result) === JSON.stringify(test.expected);
                        return { input: test.input, expected: test.expected, actual: result, passed };
                    } catch (error) {
                        return { input: test.input, expected: test.expected, error: error.message, passed: false };
                    }
                });
                return results;
            },

            reset() {
                this.errors = [];
                this.warnings = [];
            }
        };

        // STATE PERSISTENCE WITH LOCALSTORAGE
        const vmState = {
            STORAGE_KEY: 'shopResetVM',
            MAX_SIZE: 4 * 1024 * 1024, // 4MB limit

            save(data) {
                try {
                    const serialized = JSON.stringify(data);
                    if (serialized.length > this.MAX_SIZE) {
                        console.warn('State exceeds 4MB limit, compressing...');
                        // Save only essential data
                        const compressed = {
                            timestamp: data.timestamp,
                            phase: data.phase,
                            features: data.features,
                            errors: data.errors?.slice(-10) // Keep last 10 errors
                        };
                        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(compressed));
                    } else {
                        localStorage.setItem(this.STORAGE_KEY, serialized);
                    }
                    return true;
                } catch (error) {
                    vmValidation.errors.push({ message: 'Failed to save state', error });
                    return false;
                }
            },

            load() {
                try {
                    const data = localStorage.getItem(this.STORAGE_KEY);
                    return data ? JSON.parse(data) : null;
                } catch (error) {
                    vmValidation.errors.push({ message: 'Failed to load state', error });
                    return null;
                }
            },

            clear() {
                localStorage.removeItem(this.STORAGE_KEY);
            }
        };

        // EMERGENCY ROLLBACK MECHANISM
        const vmRollback = {
            snapshots: [],
            MAX_SNAPSHOTS: 5,

            createSnapshot(label) {
                const snapshot = {
                    label,
                    timestamp: Date.now(),
                    wizardState: JSON.parse(JSON.stringify(wizardState)),
                    products: [...wizardState.products],
                    validationState: {
                        errors: [...vmValidation.errors],
                        warnings: [...vmValidation.warnings]
                    }
                };

                this.snapshots.push(snapshot);

                // Keep only last MAX_SNAPSHOTS
                if (this.snapshots.length > this.MAX_SNAPSHOTS) {
                    this.snapshots.shift();
                }

                return snapshot;
            },

            restore(snapshotIndex = -1) {
                const snapshot = this.snapshots[snapshotIndex < 0 ? this.snapshots.length + snapshotIndex : snapshotIndex];
                if (!snapshot) {
                    console.error('Snapshot not found');
                    return false;
                }

                // Restore state
                Object.assign(wizardState, snapshot.wizardState);
                vmValidation.errors = [...snapshot.validationState.errors];
                vmValidation.warnings = [...snapshot.validationState.warnings];

                console.log(`Rolled back to: ${snapshot.label} (${new Date(snapshot.timestamp).toLocaleString()})`);
                return true;
            },

            emergency() {
                // Emergency rollback to last known good state
                if (this.snapshots.length === 0) {
                    console.error('No snapshots available for emergency rollback');
                    return false;
                }
                return this.restore(-1);
            }
        };

        // TIME BANKING SYSTEM
        const vmTimeBank = {
            phases: {
                phase0: { allocated: 45, actual: 0, started: null },
                phase1: { allocated: 85, actual: 0, started: null },
                phase2: { allocated: 115, actual: 0, started: null },
                phase3: { allocated: 90, actual: 0, started: null },
                phase4: { allocated: 55, actual: 0, started: null },
                phase5: { allocated: 30, actual: 0, started: null }
            },

            startPhase(phaseName) {
                if (this.phases[phaseName]) {
                    this.phases[phaseName].started = Date.now();
                }
            },

            endPhase(phaseName) {
                if (this.phases[phaseName] && this.phases[phaseName].started) {
                    const elapsed = (Date.now() - this.phases[phaseName].started) / (1000 * 60); // minutes
                    this.phases[phaseName].actual = elapsed;
                    return elapsed;
                }
                return 0;
            },

            getBank() {
                let banked = 0;
                Object.values(this.phases).forEach(phase => {
                    if (phase.actual > 0) {
                        banked += (phase.allocated - phase.actual);
                    }
                });
                return banked;
            },

            shouldSkipPhase(phaseName) {
                const bank = this.getBank();
                if (phaseName === 'phase3' && bank < 15) {
                    return true; // Skip sightlines if less than 15 min banked
                }
                return false;
            }
        };

        // TEST DATA (50 products with known characteristics)
        const vmTestData = {
            products: [
                // PAPER GOODS - High margin impulse items
                { name: 'Museum Postcards Set (10)', category: 'Paper Goods', price: 8, margin: 75, color: 'multicolor', style: 'artistic', priority: 'high' },
                { name: 'Greeting Cards Art Print', category: 'Paper Goods', price: 5, margin: 78, color: 'white', style: 'artistic', priority: 'high' },
                { name: 'Vintage Botanical Postcards', category: 'Paper Goods', price: 6, margin: 75, color: 'green', style: 'traditional', priority: 'normal' },
                { name: 'Contemporary Art Postcards', category: 'Paper Goods', price: 7, margin: 75, color: 'blue', style: 'contemporary', priority: 'normal' },
                { name: 'Sticker Sheet Art Motifs', category: 'Paper Goods', price: 4, margin: 80, color: 'multicolor', style: 'whimsical', priority: 'high' },
                { name: 'Metallic Stickers Set', category: 'Paper Goods', price: 6, margin: 78, color: 'gold', style: 'contemporary', priority: 'normal' },
                { name: 'Washi Tape Art Patterns', category: 'Paper Goods', price: 8, margin: 72, color: 'multicolor', style: 'artistic', priority: 'normal' },
                { name: 'Note Cards Museum Collection', category: 'Paper Goods', price: 12, margin: 70, color: 'white', style: 'artistic', priority: 'normal' },

                // STATIONERY - Medium-high margin
                { name: 'Hardcover Art Journal', category: 'Stationery', price: 24, margin: 65, color: 'black', style: 'contemporary', priority: 'high' },
                { name: 'Watercolor Sketchbook', category: 'Stationery', price: 28, margin: 63, color: 'white', style: 'artistic', priority: 'normal' },
                { name: 'Leather-Bound Journal', category: 'Stationery', price: 45, margin: 60, color: 'brown', style: 'traditional', priority: 'high' },
                { name: 'Minimalist Dot Grid Notebook', category: 'Stationery', price: 18, margin: 68, color: 'gray', style: 'minimalist', priority: 'normal' },
                { name: 'Artist Fountain Pen', category: 'Stationery', price: 35, margin: 62, color: 'silver', style: 'artistic', priority: 'normal' },
                { name: 'Calligraphy Pen Set', category: 'Stationery', price: 42, margin: 60, color: 'black', style: 'traditional', priority: 'normal' },
                { name: 'Colored Pencil Set Premium', category: 'Stationery', price: 32, margin: 58, color: 'multicolor', style: 'artistic', priority: 'normal' },
                { name: 'Mechanical Pencils Designer', category: 'Stationery', price: 15, margin: 65, color: 'silver', style: 'contemporary', priority: 'low' },
                { name: 'Gel Pen Set Metallic', category: 'Stationery', price: 18, margin: 66, color: 'gold', style: 'whimsical', priority: 'normal' },
                { name: 'Museum Bookmarks Tassel', category: 'Stationery', price: 6, margin: 75, color: 'multicolor', style: 'artistic', priority: 'high' },
                { name: 'Magnetic Bookmarks Set', category: 'Stationery', price: 8, margin: 72, color: 'blue', style: 'contemporary', priority: 'normal' },
                { name: 'Leather Bookmark Engraved', category: 'Stationery', price: 12, margin: 68, color: 'brown', style: 'traditional', priority: 'low' },

                // COLLECTIBLES - Very high margin small items
                { name: 'Ceramic Fridge Magnet Art', category: 'Collectibles', price: 8, margin: 74, color: 'multicolor', style: 'artistic', priority: 'high' },
                { name: 'Glass Magnet Square Modern', category: 'Collectibles', price: 10, margin: 72, color: 'blue', style: 'contemporary', priority: 'normal' },
                { name: 'Wooden Magnet Laser-Cut', category: 'Collectibles', price: 12, margin: 70, color: 'natural', style: 'minimalist', priority: 'normal' },
                { name: 'Magnet Set Museum Icons', category: 'Collectibles', price: 15, margin: 68, color: 'multicolor', style: 'artistic', priority: 'normal' },
                { name: 'Porcelain Ornament Painted', category: 'Collectibles', price: 22, margin: 65, color: 'white', style: 'traditional', priority: 'high' },
                { name: 'Glass Blown Ornament', category: 'Collectibles', price: 35, margin: 58, color: 'blue', style: 'artistic', priority: 'normal' },
                { name: 'Wooden Ornament Folk Art', category: 'Collectibles', price: 18, margin: 68, color: 'natural', style: 'whimsical', priority: 'normal' },
                { name: 'Metal Ornament Contemporary', category: 'Collectibles', price: 28, margin: 62, color: 'silver', style: 'contemporary', priority: 'normal' },
                { name: 'Enamel Pin Art Design', category: 'Collectibles', price: 12, margin: 70, color: 'multicolor', style: 'contemporary', priority: 'high' },
                { name: 'Button Badge Set Museum', category: 'Collectibles', price: 6, margin: 78, color: 'multicolor', style: 'whimsical', priority: 'normal' },

                // BAGS & TOTES - Medium margin
                { name: 'Canvas Tote Museum Logo', category: 'Bags', price: 18, margin: 62, color: 'natural', style: 'minimalist', priority: 'high' },
                { name: 'Heavy Duty Tote Art Print', category: 'Bags', price: 24, margin: 58, color: 'blue', style: 'artistic', priority: 'normal' },
                { name: 'Organic Cotton Tote', category: 'Bags', price: 22, margin: 60, color: 'white', style: 'contemporary', priority: 'normal' },
                { name: 'Reusable Shopping Bag', category: 'Bags', price: 12, margin: 65, color: 'multicolor', style: 'whimsical', priority: 'normal' },
                { name: 'Leather Tote Premium', category: 'Bags', price: 85, margin: 52, color: 'brown', style: 'traditional', priority: 'high' },
                { name: 'Zip Pouch Art Pattern', category: 'Bags', price: 16, margin: 64, color: 'multicolor', style: 'artistic', priority: 'normal' },
                { name: 'Drawstring Backpack', category: 'Bags', price: 15, margin: 65, color: 'navy', style: 'contemporary', priority: 'low' },

                // HOMEWARE - Lower margin, higher price
                { name: 'Ceramic Mug Art Collection', category: 'Homeware', price: 18, margin: 58, color: 'white', style: 'artistic', priority: 'high' },
                { name: 'Coffee Mug Museum Design', category: 'Homeware', price: 15, margin: 60, color: 'blue', style: 'contemporary', priority: 'normal' },
                { name: 'Tea Set Porcelain', category: 'Homeware', price: 65, margin: 48, color: 'white', style: 'traditional', priority: 'normal' },
                { name: 'Decorative Plate Art Motif', category: 'Homeware', price: 42, margin: 52, color: 'multicolor', style: 'artistic', priority: 'normal' },
                { name: 'Glass Vase Contemporary', category: 'Homeware', price: 55, margin: 50, color: 'clear', style: 'contemporary', priority: 'normal' },
                { name: 'Ceramic Bowl Hand-Painted', category: 'Homeware', price: 38, margin: 54, color: 'blue', style: 'artistic', priority: 'normal' },
                { name: 'Coaster Set Cork Art', category: 'Homeware', price: 16, margin: 66, color: 'natural', style: 'minimalist', priority: 'low' },
                { name: 'Throw Pillow Art Print', category: 'Homeware', price: 48, margin: 52, color: 'multicolor', style: 'artistic', priority: 'normal' },

                // BASIC APPAREL - No t-shirts, medium margin
                { name: 'Silk Scarf Art Pattern', category: 'Apparel', price: 48, margin: 58, color: 'blue', style: 'artistic', priority: 'high' },
                { name: 'Wool Scarf Museum Collection', category: 'Apparel', price: 42, margin: 60, color: 'gray', style: 'traditional', priority: 'normal' },
                { name: 'Cotton Scarf Lightweight', category: 'Apparel', price: 28, margin: 62, color: 'white', style: 'contemporary', priority: 'normal' },
                { name: 'Knit Hat Merino Wool', category: 'Apparel', price: 32, margin: 60, color: 'navy', style: 'minimalist', priority: 'normal' },
                { name: 'Linen Apron Kitchen Art', category: 'Apparel', price: 35, margin: 58, color: 'natural', style: 'artistic', priority: 'low' }
            ],

            loadTestData() {
                wizardState.products = this.products.map((p, idx) => ({
                    ...p,
                    id: idx + 1
                }));
                if (document.getElementById('previewTableBody')) {
                    renderDataPreview(wizardState.products);
                    document.getElementById('dataPreview').style.display = 'block';
                    document.getElementById('step2NextBtn').disabled = false;
                }
                showAlert('Loaded 50 arts venue gift shop products: stationery, paper goods, collectibles, bags, homeware, and apparel', 'info');
            }
        };

        // GLOBAL ERROR HANDLER
        window.addEventListener('error', (event) => {
            vmValidation.errors.push({
                message: event.message,
                severity: 'error',
                source: event.filename,
                line: event.lineno,
                timestamp: Date.now()
            });

            // Emergency rollback if too many errors
            if (vmValidation.errors.length > 10) {
                console.error('Too many errors detected, triggering emergency rollback');
                vmRollback.emergency();
            }
        });

        // ==================== PHASE 1: PRICE POINT LADDER ANALYSIS ====================

        const priceLadder = {
            tiers: [
                { name: 'Budget', min: 0, max: 10, products: [] },
                { name: 'Value', min: 10, max: 25, products: [] },
                { name: 'Mid-Range', min: 25, max: 50, products: [] },
                { name: 'Premium', min: 50, max: 100, products: [] },
                { name: 'Luxury', min: 100, max: 250, products: [] },
                { name: 'Ultra-Luxury', min: 250, max: Infinity, products: [] }
            ],

            analyzePriceDistribution(products) {
                this.tiers.forEach(tier => tier.products = []);
                products.forEach(product => {
                    const tier = this.tiers.find(t => product.price >= t.min && product.price < t.max);
                    if (tier) tier.products.push(product);
                });

                return this.tiers.map(tier => ({
                    name: tier.name,
                    range: `$${tier.min}-${tier.max === Infinity ? '+' : tier.max}`,
                    count: tier.products.length,
                    percentage: Math.round((tier.products.length / products.length) * 100),
                    avgMargin: tier.products.length > 0
                        ? Math.round(tier.products.reduce((sum, p) => sum + p.margin, 0) / tier.products.length) : 0,
                    totalValue: tier.products.reduce((sum, p) => sum + p.price * (p.margin / 100), 0)
                }));
            },

            identifyGaps(stats) {
                const gaps = [];
                stats.forEach((tier, idx) => {
                    if (tier.count === 0) {
                        gaps.push({
                            tier: tier.name, range: tier.range,
                            severity: (idx === 1 || idx === 2) ? 'critical' : (idx === 0 || idx === 3) ? 'high' : 'medium',
                            recommendation: this.getGapRecommendation(tier.name, idx)
                        });
                    } else if (tier.percentage < 10 && tier.percentage > 0) {
                        gaps.push({
                            tier: tier.name, range: tier.range, severity: 'warning',
                            recommendation: `Consider adding more ${tier.name.toLowerCase()} options (currently only ${tier.count} items)`
                        });
                    }
                });
                return gaps;
            },

            getGapRecommendation(tierName, tierIndex) {
                const recs = [
                    'Add budget-friendly items to capture price-conscious shoppers',
                    'CRITICAL: Missing value-tier products. This is the most shopped price range',
                    'CRITICAL: Mid-range gap detected. Most customers expect options here',
                    'Add premium items to create aspirational purchases',
                    'Consider luxury items to anchor high-end positioning',
                    'Ultra-luxury items serve as conversation starters'
                ];
                return recs[tierIndex] || `Add products in ${tierName} range`;
            },

            generateHistogramHTML(stats, gaps) {
                const maxCount = Math.max(...stats.map(s => s.count), 1);
                let html = '<div style="background: #0a0e1a; padding: 24px; border-radius: 8px; margin: 20px 0;">';
                html += '<h3 style="color: #667eea; margin-bottom: 16px;">Price Point Distribution</h3>';

                stats.forEach(tier => {
                    const barWidth = Math.round((tier.count / maxCount) * 100);
                    const gapInfo = gaps.find(g => g.tier === tier.name);
                    const barColor = gapInfo ? '#ef4444' : (tier.percentage >= 15 ? '#22c55e' : '#f59e0b');

                    html += `<div style="margin-bottom: 16px;">`;
                    html += `<div style="display: flex; justify-content: space-between; margin-bottom: 4px;">`;
                    html += `<span style="color: #e0e0e0; font-weight: 600;">${tier.name}</span>`;
                    html += `<span style="color: #94a3b8;">${tier.range}</span></div>`;
                    html += `<div style="background: #1e293b; height: 24px; border-radius: 4px; overflow: hidden;">`;
                    if (tier.count > 0) html += `<div style="background: ${barColor}; width: ${barWidth}%; height: 100%;"></div>`;
                    html += `</div>`;
                    html += `<div style="font-size: 12px; color: #64748b; margin-top: 4px;">`;
                    html += `${tier.count} products (${tier.percentage}%)`;
                    if (tier.count > 0) html += ` | Avg Margin: ${tier.avgMargin}% | Value: $${Math.round(tier.totalValue)}`;
                    html += `</div>`;

                    if (gapInfo) {
                        const colors = { critical: '#ef4444', high: '#f59e0b', medium: '#3b82f6', warning: '#f59e0b' };
                        html += `<div style="background: rgba(239,68,68,0.1); border-left: 3px solid ${colors[gapInfo.severity]}; padding: 8px; margin-top: 8px; border-radius: 4px;">`;
                        html += `<div style="color: ${colors[gapInfo.severity]}; font-size: 11px; font-weight: 600;">${gapInfo.severity.toUpperCase()}</div>`;
                        html += `<div style="color: #94a3b8; font-size: 12px; margin-top: 4px;">${gapInfo.recommendation}</div></div>`;
                    }
                    html += `</div>`;
                });

                html += '</div>';
                return html;
            }
        };

        // ==================== PHASE 2: GOLDEN TRIANGLE TRAFFIC FLOW ====================

        const trafficFlow = {
            entrance: { x: 0, y: 0 },
            focalPoint: null,
            cashwrap: null,
            trianglePath: [],
            decompressionZone: 15, // First 15 feet

            setPoints(entrance, focal, cashwrap) {
                this.entrance = entrance || { x: 0, y: 0 };
                this.focalPoint = focal || { x: 50, y: 50 };
                this.cashwrap = cashwrap || { x: 0, y: 100 };
                this.calculateTrianglePath();
            },

            calculateTrianglePath() {
                this.trianglePath = [
                    this.entrance,
                    this.focalPoint,
                    this.cashwrap,
                    this.entrance
                ];
            },

            calculateDistance(point1, point2) {
                const dx = point2.x - point1.x;
                const dy = point2.y - point1.y;
                return Math.sqrt(dx * dx + dy * dy);
            },

            isPointNearPath(point, threshold = 10) {
                // Check if point is within threshold distance of any path segment
                for (let i = 0; i < this.trianglePath.length - 1; i++) {
                    const p1 = this.trianglePath[i];
                    const p2 = this.trianglePath[i + 1];
                    const dist = this.distanceToLineSegment(point, p1, p2);
                    if (dist < threshold) return true;
                }
                return false;
            },

            distanceToLineSegment(point, lineStart, lineEnd) {
                const A = point.x - lineStart.x;
                const B = point.y - lineStart.y;
                const C = lineEnd.x - lineStart.x;
                const D = lineEnd.y - lineStart.y;

                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;

                if (lenSq !== 0) param = dot / lenSq;

                let xx, yy;

                if (param < 0) {
                    xx = lineStart.x;
                    yy = lineStart.y;
                } else if (param > 1) {
                    xx = lineEnd.x;
                    yy = lineEnd.y;
                } else {
                    xx = lineStart.x + param * C;
                    yy = lineStart.y + param * D;
                }

                const dx = point.x - xx;
                const dy = point.y - yy;
                return Math.sqrt(dx * dx + dy * dy);
            },

            scoreProductByPath(product, fixtureLocation) {
                const loc = fixtureLocation || { x: Math.random() * 100, y: Math.random() * 100 };

                // Check decompression zone violation
                const distFromEntrance = this.calculateDistance(loc, this.entrance);
                if (distFromEntrance < this.decompressionZone && product.baseValue > 100) {
                    return {
                        score: 0,
                        category: 'decompression-violation',
                        warning: 'High-value item in decompression zone',
                        recommendation: 'Move to deeper store location'
                    };
                }

                // Calculate proximity to golden triangle path
                const onPath = this.isPointNearPath(loc, 5);
                const nearPath = this.isPointNearPath(loc, 15);

                if (onPath) {
                    return {
                        score: 100,
                        category: 'on-path',
                        color: '#22c55e',
                        label: 'On Golden Triangle'
                    };
                } else if (nearPath) {
                    return {
                        score: 65,
                        category: 'near-path',
                        color: '#f59e0b',
                        label: 'Near Traffic Path'
                    };
                } else {
                    return {
                        score: 30,
                        category: 'off-path',
                        color: '#ef4444',
                        label: 'Off Main Path'
                    };
                }
            },

            analyzeAllFixtures(fixtureMap) {
                const results = fixtureMap.map(fixture => {
                    const score = this.scoreProductByPath(
                        { baseValue: fixture.averageProductValue || 50 },
                        fixture.location
                    );
                    return {
                        fixtureName: fixture.name,
                        location: fixture.location,
                        pathScore: score
                    };
                });

                return {
                    onPath: results.filter(r => r.pathScore.category === 'on-path').length,
                    nearPath: results.filter(r => r.pathScore.category === 'near-path').length,
                    offPath: results.filter(r => r.pathScore.category === 'off-path').length,
                    violations: results.filter(r => r.pathScore.category === 'decompression-violation').length,
                    fixtures: results
                };
            },

            generateVisualizationHTML(storeWidth, storeHeight, fixtureAnalysis) {
                const scaleX = 600 / storeWidth;
                const scaleY = 400 / storeHeight;

                let html = '<div style="background: #0a0e1a; padding: 24px; border-radius: 8px; margin: 20px 0;">';
                html += '<h3 style="color: #667eea; margin-bottom: 16px;">Golden Triangle Traffic Flow</h3>';

                // SVG visualization
                html += `<svg width="600" height="400" style="background: #1e293b; border-radius: 8px;">`;

                // Draw decompression zone
                const decompressionRadius = this.decompressionZone * scaleX;
                html += `<circle cx="${this.entrance.x * scaleX}" cy="${this.entrance.y * scaleY}" r="${decompressionRadius}" fill="rgba(239,68,68,0.1)" stroke="#ef4444" stroke-width="1" stroke-dasharray="5,5"/>`;

                // Draw golden triangle path
                html += `<path d="M ${this.entrance.x * scaleX},${this.entrance.y * scaleY} L ${this.focalPoint.x * scaleX},${this.focalPoint.y * scaleY} L ${this.cashwrap.x * scaleX},${this.cashwrap.y * scaleY} Z" fill="rgba(102,126,234,0.1)" stroke="#667eea" stroke-width="2"/>`;

                // Draw key points
                html += `<circle cx="${this.entrance.x * scaleX}" cy="${this.entrance.y * scaleY}" r="8" fill="#22c55e"/>`;
                html += `<text x="${this.entrance.x * scaleX}" y="${this.entrance.y * scaleY - 12}" fill="#22c55e" font-size="12" text-anchor="middle">Entrance</text>`;

                html += `<circle cx="${this.focalPoint.x * scaleX}" cy="${this.focalPoint.y * scaleY}" r="8" fill="#667eea"/>`;
                html += `<text x="${this.focalPoint.x * scaleX}" y="${this.focalPoint.y * scaleY - 12}" fill="#667eea" font-size="12" text-anchor="middle">Focal</text>`;

                html += `<circle cx="${this.cashwrap.x * scaleX}" cy="${this.cashwrap.y * scaleY}" r="8" fill="#f59e0b"/>`;
                html += `<text x="${this.cashwrap.x * scaleX}" y="${this.cashwrap.y * scaleY - 12}" fill="#f59e0b" font-size="12" text-anchor="middle">Cashwrap</text>`;

                html += `</svg>`;

                // Traffic flow summary
                html += `<div style="margin-top: 16px; display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px;">`;
                html += `<div style="background: rgba(34,197,94,0.1); padding: 12px; border-radius: 6px; border-left: 3px solid #22c55e;">`;
                html += `<div style="color: #22c55e; font-weight: 600;">${fixtureAnalysis.onPath} Fixtures</div>`;
                html += `<div style="color: #94a3b8; font-size: 12px;">On Golden Triangle</div></div>`;
                html += `<div style="background: rgba(245,158,11,0.1); padding: 12px; border-radius: 6px; border-left: 3px solid #f59e0b;">`;
                html += `<div style="color: #f59e0b; font-weight: 600;">${fixtureAnalysis.nearPath} Fixtures</div>`;
                html += `<div style="color: #94a3b8; font-size: 12px;">Near Main Path</div></div>`;
                html += `<div style="background: rgba(239,68,68,0.1); padding: 12px; border-radius: 6px; border-left: 3px solid #ef4444;">`;
                html += `<div style="color: #ef4444; font-weight: 600;">${fixtureAnalysis.offPath} Fixtures</div>`;
                html += `<div style="color: #94a3b8; font-size: 12px;">Off Main Path</div></div>`;
                html += `</div>`;

                if (fixtureAnalysis.violations > 0) {
                    html += `<div style="background: rgba(239,68,68,0.1); border-left: 3px solid #ef4444; padding: 12px; margin-top: 12px; border-radius: 6px;">`;
                    html += `<div style="color: #ef4444; font-weight: 600;">⚠ ${fixtureAnalysis.violations} Decompression Zone Violations</div>`;
                    html += `<div style="color: #94a3b8; font-size: 12px; margin-top: 4px;">High-value items detected in first ${this.decompressionZone} feet. Customers need space to transition into shopping mode.</div>`;
                    html += `</div>`;
                }

                html += '</div>';
                return html;
            }
        };

        // PHASE 0 CHECKPOINT VALIDATION
        function runPhase0Validation() {
            console.log('Running Phase 0 validation checks...');

            const checks = [
                {
                    name: 'Backup system exists',
                    fn: () => typeof vmRollback.createSnapshot === 'function'
                },
                {
                    name: 'Emergency rollback works',
                    fn: () => {
                        vmRollback.createSnapshot('test');
                        return vmRollback.snapshots.length > 0;
                    }
                },
                {
                    name: 'Validation framework ready',
                    fn: () => typeof vmValidation.assertVM === 'function'
                },
                {
                    name: 'State persistence ready',
                    fn: () => {
                        const testData = { test: 'data', timestamp: Date.now() };
                        vmState.save(testData);
                        const loaded = vmState.load();
                        return loaded && loaded.test === 'data';
                    }
                },
                {
                    name: 'Time banking initialized',
                    fn: () => Object.keys(vmTimeBank.phases).length === 6
                },
                {
                    name: 'Test data available',
                    fn: () => vmTestData.products.length === 50
                },
                {
                    name: 'Test data has required fields',
                    fn: () => {
                        const required = ['name', 'category', 'price', 'margin', 'color', 'style', 'priority'];
                        return vmTestData.products.every(p =>
                            required.every(field => p.hasOwnProperty(field))
                        );
                    }
                },
                {
                    name: 'Price range validation',
                    fn: () => {
                        const prices = vmTestData.products.map(p => p.price);
                        return Math.min(...prices) >= 15 && Math.max(...prices) <= 400;
                    }
                },
                {
                    name: 'Category diversity',
                    fn: () => {
                        const categories = new Set(vmTestData.products.map(p => p.category));
                        return categories.size >= 6;
                    }
                },
                {
                    name: 'Style diversity',
                    fn: () => {
                        const styles = new Set(vmTestData.products.map(p => p.style));
                        return styles.size >= 3;
                    }
                },
                {
                    name: 'Priority distribution',
                    fn: () => {
                        const priorities = vmTestData.products.map(p => p.priority);
                        return priorities.includes('high') && priorities.includes('normal') && priorities.includes('low');
                    }
                },
                {
                    name: 'Color variety',
                    fn: () => {
                        const colors = new Set(vmTestData.products.map(p => p.color));
                        return colors.size >= 8;
                    }
                },
                {
                    name: 'Margin range check',
                    fn: () => {
                        const margins = vmTestData.products.map(p => p.margin);
                        return Math.min(...margins) >= 45 && Math.max(...margins) <= 75;
                    }
                },
                {
                    name: 'Global error handler active',
                    fn: () => {
                        // Check if error event listener is registered
                        const testError = new Error('Test validation');
                        const originalLength = vmValidation.errors.length;
                        window.dispatchEvent(new ErrorEvent('error', {
                            message: 'Test',
                            filename: 'test.js',
                            lineno: 1
                        }));
                        const captured = vmValidation.errors.length > originalLength;
                        if (captured) vmValidation.errors.pop(); // Clean up test error
                        return captured;
                    }
                }
            ];

            const results = vmValidation.runChecks(checks);
            const passed = results.filter(r => r.passed).length;
            const total = results.length;

            console.log(`Phase 0 Validation: ${passed}/${total} checks passed`);

            if (passed === total) {
                console.log('✓ Phase 0 Infrastructure: READY');
                vmRollback.createSnapshot('Phase 0 Complete');
                return true;
            } else {
                console.error('✗ Phase 0 Infrastructure: FAILED');
                results.filter(r => !r.passed).forEach(r => {
                    console.error(`  - ${r.name}: ${r.error || 'Failed'}`);
                });
                return false;
            }
        }

    </script>
</body>
</html>
