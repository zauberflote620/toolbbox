<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level 3: Living Gallery - Gallery Keeper</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1B5E20 0%, #2E7D32 100%);
            color: #ECF0F1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            min-height: 100vh;
        }

        h1 {
            color: #81C784;
            margin-bottom: 10px;
            text-align: center;
        }

        .subtitle {
            color: #C5E1A5;
            margin-bottom: 20px;
            text-align: center;
        }

        .game-container {
            background: #2E7D32;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 940px;
            width: 100%;
        }

        canvas {
            display: block;
            background: linear-gradient(135deg, #E8F5E9 0%, #F1F8E9 50%, #FFF9C4 100%);
            border-radius: 12px;
            margin: 0 auto 20px;
            box-shadow:
                0 10px 40px rgba(0, 0, 0, 0.3),
                0 2px 8px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            cursor: default;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #66BB6A 0%, #4CAF50 100%);
            color: white;
            box-shadow:
                0 4px 12px rgba(76, 175, 80, 0.4),
                0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);
            transform: translateY(-2px);
            box-shadow:
                0 6px 16px rgba(76, 175, 80, 0.5),
                0 3px 6px rgba(0, 0, 0, 0.3);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #95A5A6 0%, #7F8C8D 100%);
            color: white;
            box-shadow:
                0 4px 12px rgba(149, 165, 166, 0.3),
                0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #7F8C8D 0%, #5D6D7E 100%);
            transform: translateY(-2px);
            box-shadow:
                0 6px 16px rgba(149, 165, 166, 0.4),
                0 3px 6px rgba(0, 0, 0, 0.3);
        }

        .instructions {
            background: #1B5E20;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .instructions h3 {
            color: #81C784;
            margin-bottom: 10px;
        }

        .instructions ul {
            margin-left: 20px;
            line-height: 1.8;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Gallery Keeper: Living Gallery</h1>
        <p class="subtitle">Level 3 - Feynman's Environmental Challenge</p>

        <canvas id="gameCanvas" width="900" height="650"></canvas>

        <div class="controls">
            <a href="index.html" class="btn btn-secondary" style="text-decoration: none;">Back to Gallery</a>
        </div>

        <div class="instructions">
            <h3>How to Play</h3>
            <ul>
                <li><strong>Goal:</strong> Create a happy environment for gallery visitors</li>
                <li><strong>Water plants:</strong> Click plants to water them (they'll grow and bloom!)</li>
                <li><strong>Adjust lighting:</strong> Control tree brightness (light emanates from center)</li>
                <li><strong>Clean dirt:</strong> Click dirt spots to clean them</li>
                <li><strong>Watch visitors:</strong> They'll naturally gravitate to pleasant areas</li>
                <li><strong>Victory:</strong> Maintain 75%+ visitor happiness for 3 continuous minutes</li>
            </ul>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        const game = {
            // Time tracking
            time: 0,
            victoryState: false,
            victoryTimer: 0,
            gameStarted: false,
            startButtonHover: false,
            paused: false,

            // Tutorial
            tutorialStep: 0,
            tutorialStarted: false,
            feynmanMessage: '',
            messageTimer: 0,
            tutorialComplete: false,
            tutorialTimeout: null,
            tutorialMessageBounds: null,

            // Plant system (6 plant zones around the central branch)
            plants: [],
            plantZones: [
                { x: 150, y: 180, waterLevel: 50, growthStage: 1, type: 'normal' },
                { x: 350, y: 150, waterLevel: 50, growthStage: 1, type: 'normal' },
                { x: 650, y: 180, waterLevel: 50, growthStage: 1, type: 'normal' },
                { x: 150, y: 450, waterLevel: 50, growthStage: 1, type: 'normal' },
                { x: 350, y: 480, waterLevel: 50, growthStage: 1, type: 'normal' },
                { x: 650, y: 450, waterLevel: 50, growthStage: 1, type: 'normal' }
            ],

            // Central branch anchor
            branchX: 450,
            branchY: 320,
            branchWaterLevel: 50, // Branch itself needs watering
            branchAuraColor: 'rgba(255, 255, 255, 0.3)',
            branchAuraMessage: '',

            // Groot popup (appears when plants are fully watered)
            grootPopup: false,
            grootPopupTimer: 0,
            grootPopupScale: 0,
            grootPopupAlpha: 0,
            grootCooldown: 0, // Cooldown timer to prevent repeated triggers

            // Lighting system (emanates from center tree)
            treeBrightness: 1, // 0=off, 1=normal, 2=bright
            treeLightRadius: 200, // Light radius based on brightness
            lightFlashTimer: 0, // Flash effect when changing brightness

            // Cleanliness system
            dirtSpots: [],
            dirtSpawnTimer: 0,
            dirtSpawnInterval: 30, // Spawn dirt every 30 seconds (more forgiving)

            // Visitor AI
            visitors: [],
            visitorSpawnTimer: 0,
            visitorSpawnInterval: 2.5, // Spawn visitor every 2.5 seconds
            maxVisitors: 10,

            // Environmental scoring
            overallHappiness: 0, // 0-100
            happinessHistory: [], // Track happiness over time
            timeAtTargetHappiness: 0, // Seconds at 80%+ happiness
            targetHappiness: 75, // Lowered from 80 to 75
            targetDuration: 180, // 3 minutes = 180 seconds (down from 5 minutes)

            // Tool selection
            currentTool: 'water', // 'water', 'clean', 'light'

            // UI elements
            toolButtons: [],
            restartButtonCanvasBounds: null,
            pauseButtonBounds: null,

            // Visual effects
            particles: [],
            screenShake: 0,
            confetti: [],

            // Feynman NPC
            feynmanX: 700,
            feynmanY: 50,
            feynmanExcited: false,
            feynmanReactionTimer: 0,
            lastHappiness: 50,
            discoveryMade: {
                bloomingPlants: false,
                cleanEnvironment: false,
                perfectLighting: false,
                synergy: false
            },

            // Images
            images: {},
            imagesLoaded: false,
            visitorSpritePool: [
                'stick_unsure', 'stick_confused', 'stick_explaining2', 'stick_looking',
                'stick_look_left', 'stick_look_right', 'stick_secret',
                'stick_hat', 'stick_ponytail_pamplet'
            ],

            // Mouse tracking for hover effects
            mouseX: 0,
            mouseY: 0,

            // Timer
            timeRemaining: 300, // 5 minutes countdown
            maxTime: 300, // 5 minutes max time limit
            lastHappinessForBonus: 50,

            // Game over state
            gameOverState: false,
            gameOverTimer: 0,
            skullScale: 0,
            skullAlpha: 0,

            // Surprise elements (rare events)
            chicken: null, // One chicken per game max
            chickenSpawned: false,
            thunderCloud: null,
            cloudTimer: 0,
            cloudSpawnInterval: 90, // Cloud appears every ~90 seconds (less frequent)

            // Helper character (stick_hands_hip)
            helper: {
                x: canvas.width - 250, // Closer to center
                y: canvas.height - 150,
                targetX: canvas.width - 250,
                targetY: canvas.height - 150,
                moving: false
            }
        };

        // Initialize game
        function init() {
            console.log('Level 3: Living Gallery - Initializing...');

            // Load images first
            loadImages();

            // Initialize plant zones
            game.plants = game.plantZones.map((zone, i) => ({
                id: i,
                x: zone.x,
                y: zone.y,
                waterLevel: 50,
                growthStage: 1, // 0=wilted, 1=healthy, 2=blooming
                wateringAnimation: 0,
                type: zone.type || 'normal',
                isSpecial: zone.isSpecial || false
            }));

            // Initialize dirt spots (start with a few)
            for (let i = 0; i < 3; i++) {
                spawnDirt();
            }

            // Setup tool buttons
            game.toolButtons = [
                { tool: 'water', x: 20, y: 100, w: 80, h: 60, label: 'Water', icon: '💧' },
                { tool: 'clean', x: 20, y: 180, w: 80, h: 60, label: 'Clean', icon: '🧹' },
                { tool: 'light', x: 20, y: 260, w: 80, h: 60, label: 'Light', icon: '💡' }
            ];

            // Don't start tutorial automatically - wait for start button click
        }

        function loadImages() {
            const imagesToLoad = {
                // Stick figures from stick_figures/
                'stick_unsure': '../Excalidraw/assets/stick_figures/stick_unsure.png',
                'stick_confused': '../Excalidraw/assets/stick_figures/stick_confused.png',
                'stick_explaining2': '../Excalidraw/assets/stick_figures/stick_explaining_2.png',
                'stick_looking': '../Excalidraw/assets/stick_figures/stick_looking.png',
                'stick_look_left': '../Excalidraw/assets/stick_figures/stick_look_left.png',
                'stick_look_right': '../Excalidraw/assets/stick_figures/stick_look_right.png',
                'stick_secret': '../Excalidraw/assets/stick_figures/stick_secret.png',
                'stick1_jump': '../Excalidraw/assets/stick_figures/stick1_jump.png',

                // Stick figures from stick_ppl/
                'stick_hat': '../Excalidraw/assets/stick_ppl/stick_hat.png',
                'stick_mustache': '../Excalidraw/assets/stick_ppl/stick_mustache.png',
                'stick_ponytail_pamplet': '../Excalidraw/assets/stick_ppl/stick_ponytail_pamplet.png',
                'stick_sad': '../Excalidraw/assets/stick_ppl/stick_sad.png',
                'stick_hands_hip': '../Excalidraw/assets/stick_figures/stick-hands-hip.svg',

                // Special assets
                'branch': '../Excalidraw/assets/nature/branches.png',
                'groot': '../Excalidraw/assets/nature/i-am-groot.svg',
                'skull': '../Excalidraw/assets/symbols/skull_red.png',
                'alarm': '../Excalidraw/assets/objects/alarm-red.svg',

                // Surprise elements (chickens and weather)
                'chick_left': '../Excalidraw/assets/creatures/chick-left-to-right.svg',
                'chick_right': '../Excalidraw/assets/creatures/chick-right-to-left.svg',
                'chicken_left': '../Excalidraw/assets/creatures/chicken-left-to-right.svg',
                'chicken_right': '../Excalidraw/assets/creatures/chicken-right-to-left.svg',
                'thunder_cloud': '../Excalidraw/assets/nature/rain-cloud-thunder.svg'
            };

            let loadedCount = 0;
            const totalImages = Object.keys(imagesToLoad).length;

            Object.entries(imagesToLoad).forEach(([key, src]) => {
                const img = new Image();
                img.onload = () => {
                    loadedCount++;
                    if (loadedCount === totalImages) {
                        game.imagesLoaded = true;
                        console.log('All images loaded successfully');
                    }
                };
                img.onerror = () => {
                    console.warn(`Failed to load image: ${key} from ${src}`);
                    loadedCount++;
                    if (loadedCount === totalImages) {
                        game.imagesLoaded = true;
                    }
                };
                img.src = src;
                game.images[key] = img;
            });
        }

        function showTutorial() {
            game.tutorialStarted = true; // Mark tutorial as started

            // Clear any existing timeout
            if (game.tutorialTimeout) {
                clearTimeout(game.tutorialTimeout);
                game.tutorialTimeout = null;
            }

            const messages = [
                "Welcome to the Living Gallery! I'm Richard Feynman.",
                "Your goal: create an environment where visitors feel happy.",
                "Water plants, control the tree's light, and keep things clean.",
                "Visitors will naturally move toward pleasant areas.",
                "Experiment! Try different combinations and observe what happens.",
                "Maintain 75% happiness for 3 minutes to win. Good luck!"
            ];

            if (game.tutorialStep < messages.length) {
                game.feynmanMessage = messages[game.tutorialStep];
                game.messageTimer = 3;
                game.tutorialStep++;

                if (game.tutorialStep >= messages.length) {
                    game.tutorialComplete = true;
                    game.tutorialTimeout = setTimeout(() => {
                        game.gameStarted = true;
                        // Clear tutorial message when game starts
                        game.feynmanMessage = '';
                        game.messageTimer = 0;
                        // Move helper to Feynman position
                        game.helper.targetX = game.feynmanX;
                        game.helper.targetY = game.feynmanY;
                        game.helper.moving = true;
                    }, 3000);
                } else {
                    game.tutorialTimeout = setTimeout(() => showTutorial(), 3000);
                }
            }
        }

        function spawnDirt() {
            // Random position within gallery bounds
            const x = 150 + Math.random() * 600;
            const y = 150 + Math.random() * 400;

            game.dirtSpots.push({
                x: x,
                y: y,
                size: 15 + Math.random() * 10,
                cleanLevel: 100 // 0=clean, 100=very dirty
            });
        }

        function spawnVisitor() {
            if (game.visitors.length >= game.maxVisitors) return;

            // Random entry point (top or sides)
            const spawnSide = Math.floor(Math.random() * 3);
            let x, y;

            if (spawnSide === 0) { // Top
                x = 200 + Math.random() * 500;
                y = 100;
            } else if (spawnSide === 1) { // Left
                x = 120;
                y = 150 + Math.random() * 400;
            } else { // Right
                x = 780;
                y = 150 + Math.random() * 400;
            }

            // Assign random sprite from pool
            const randomSprite = game.visitorSpritePool[Math.floor(Math.random() * game.visitorSpritePool.length)];

            game.visitors.push({
                id: Date.now() + Math.random(),
                x: x,
                y: y,
                vx: 0,
                vy: 0,
                happiness: 50, // 0-100
                targetX: null,
                targetY: null,
                speed: 30 + Math.random() * 20,
                idleTimer: 0,
                sprite: randomSprite // Assigned sprite for this visitor
            });
        }

        function updatePlants(dt) {
            game.plants.forEach(plant => {
                // Water evaporates over time (much slower, very forgiving)
                let decayRate = 0.25; // Base decay (plants last ~6.7 minutes)

                // Groot bonus: decay even slower when Groot is active
                if (game.grootPopup && game.grootPopupTimer < 2.5) {
                    decayRate *= 0.4; // 60% slower decay when Groot up
                }

                plant.waterLevel -= decayRate * dt;
                if (plant.waterLevel < 0) plant.waterLevel = 0;
                if (plant.waterLevel > 100) plant.waterLevel = 100;

                // Update growth stage based on water level
                if (plant.waterLevel < 20) {
                    plant.growthStage = 0; // Wilted
                } else if (plant.waterLevel < 70) {
                    plant.growthStage = 1; // Healthy
                } else {
                    plant.growthStage = 2; // Blooming
                }

                // Decay watering animation
                if (plant.wateringAnimation > 0) {
                    plant.wateringAnimation -= dt * 2;
                }
            });

            // Update cooldown timer
            if (game.grootCooldown > 0) {
                game.grootCooldown -= dt;
                if (game.grootCooldown < 0) game.grootCooldown = 0;
            }

            // Check for Groot popup (any plant fully watered)
            const allPlantsFullyWatered = game.plants.some(p => p.waterLevel >= 95);

            // Only trigger if not in cooldown, not already showing, and plants are fully watered
            if (allPlantsFullyWatered && !game.grootPopup && game.grootCooldown === 0) {
                game.grootPopup = true;
                game.grootPopupTimer = 0;
                game.grootPopupScale = 0;
                game.grootPopupAlpha = 0;
            }

            // Update Groot popup animation
            if (game.grootPopup) {
                if (game.grootPopupTimer < 3) {
                    game.grootPopupTimer += dt;

                    // Animation sequence:
                    // 0-1 sec: Stay at tree (scale = 1, alpha = 1)
                    // 1-2 sec: Zoom toward user (scale 1 -> 2.5, alpha = 1)
                    // 2-3 sec: Fade out (scale = 2.5, alpha 1 -> 0)

                    if (game.grootPopupTimer < 1) {
                        // Phase 1: Stay at tree
                        game.grootPopupScale = 1;
                        game.grootPopupAlpha = 1;
                    } else if (game.grootPopupTimer < 2) {
                        // Phase 2: Zoom toward user
                        const t = (game.grootPopupTimer - 1); // 0 to 1 over 1 second
                        // Elastic easing out with overshoot
                        const p = 0.3;
                        const s = p / 4;
                        const easeT = Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
                        game.grootPopupScale = 1 + easeT * 1.5; // 1 to 2.5
                        game.grootPopupAlpha = 1;
                    } else {
                        // Phase 3: Fade out
                        game.grootPopupScale = 2.5;
                        const fadeT = (game.grootPopupTimer - 2); // 0 to 1 over 1 second
                        game.grootPopupAlpha = 1 - fadeT;
                        if (game.grootPopupAlpha < 0) game.grootPopupAlpha = 0;
                    }
                } else {
                    // Animation complete - reset and start cooldown
                    game.grootPopup = false;
                    game.grootPopupTimer = 0;
                    game.grootPopupScale = 0;
                    game.grootPopupAlpha = 0;
                    game.grootCooldown = 10;
                }
            }
        }

        function updateBranchAura(dt) {
            // Branch itself needs watering
            let branchDecayRate = 0.30; // Base decay (lasts ~5.5 minutes)

            // Groot bonus: branch decay slower too
            if (game.grootPopup && game.grootPopupTimer < 2.5) {
                branchDecayRate *= 0.4; // 60% slower when Groot active
            }

            game.branchWaterLevel -= branchDecayRate * dt;
            if (game.branchWaterLevel < 0) game.branchWaterLevel = 0;
            if (game.branchWaterLevel > 100) game.branchWaterLevel = 100;

            // Determine what condition needs attention and set branch aura accordingly
            const avgWaterLevel = game.plants.reduce((sum, p) => sum + p.waterLevel, 0) / game.plants.length;
            const dirtCount = game.dirtSpots.length;

            // Check if tree light is off
            const branchInDarkness = game.treeBrightness === 0;

            const avgHappiness = game.overallHappiness;

            // Priority: branch water > darkness > plant water > dirt > happiness
            if (game.branchWaterLevel < 30) {
                game.branchAuraColor = 'rgba(33, 150, 243, 0.6)'; // Blue - branch needs water
                game.branchAuraMessage = 'Branch needs water!';
            } else if (branchInDarkness) {
                game.branchAuraColor = 'rgba(80, 80, 80, 0.7)'; // Grey - dark zone
                game.branchAuraMessage = 'Too dark here!';
            } else if (avgWaterLevel < 40) {
                game.branchAuraColor = 'rgba(33, 150, 243, 0.5)'; // Blue - plants need water
                game.branchAuraMessage = 'Plants need water';
            } else if (dirtCount > 3) {
                game.branchAuraColor = 'rgba(139, 69, 19, 0.5)'; // Brown - needs cleaning
                game.branchAuraMessage = 'Too much dirt';
            } else if (avgHappiness < 60) {
                game.branchAuraColor = 'rgba(244, 67, 54, 0.4)'; // Red - low happiness
                game.branchAuraMessage = 'Visitors unhappy';
            } else {
                game.branchAuraColor = 'rgba(76, 175, 80, 0.4)'; // Green - all good
                game.branchAuraMessage = 'Environment healthy';
            }
        }

        function updateLighting(dt) {
            // Update flash timer
            if (game.lightFlashTimer > 0) {
                game.lightFlashTimer -= dt;
            }

            // Update tree light radius based on brightness
            if (game.treeBrightness === 0) {
                game.treeLightRadius = 80; // Off - minimal glow
            } else if (game.treeBrightness === 1) {
                game.treeLightRadius = 200; // Normal - medium aura
            } else if (game.treeBrightness === 2) {
                game.treeLightRadius = 320; // Bright - large aura
            }
        }

        function updateDirt(dt) {
            // Spawn new dirt periodically
            game.dirtSpawnTimer += dt;
            if (game.dirtSpawnTimer >= game.dirtSpawnInterval) {
                game.dirtSpawnTimer = 0;
                spawnDirt();
            }
        }

        function updateChicken(dt) {
            // Spawn chicken (VERY RARE - only once per game)
            if (!game.chickenSpawned && Math.random() < 0.0003) { // ~0.03% chance per frame
                const types = ['chick_left', 'chick_right', 'chicken_left', 'chicken_right'];
                const type = types[Math.floor(Math.random() * types.length)];
                const direction = type.includes('left') ? 1 : -1;

                game.chicken = {
                    type: type,
                    x: direction > 0 ? -60 : canvas.width + 60,
                    y: 450 + Math.random() * 100, // Bottom area
                    speed: 80,
                    direction: direction,
                    size: type.includes('chick') ? 30 : 40
                };
                game.chickenSpawned = true;
            }

            // Update chicken position
            if (game.chicken) {
                game.chicken.x += game.chicken.speed * game.chicken.direction * dt;

                // Remove when off screen
                if (game.chicken.direction > 0 && game.chicken.x > canvas.width + 60) {
                    game.chicken = null;
                } else if (game.chicken.direction < 0 && game.chicken.x < -60) {
                    game.chicken = null;
                }
            }
        }

        function updateThunderCloud(dt) {
            // Spawn thunder cloud periodically
            game.cloudTimer += dt;
            if (game.cloudTimer >= game.cloudSpawnInterval && !game.thunderCloud) {
                game.cloudTimer = 0;
                const direction = Math.random() < 0.5 ? 1 : -1;

                game.thunderCloud = {
                    x: direction > 0 ? -100 : canvas.width + 100,
                    y: 80 + Math.random() * 40,
                    speed: 60,
                    direction: direction,
                    bobOffset: 0,
                    wateredPlants: [], // Track which plants have been watered
                    wateredBranch: false,
                    lastDirtX: null // Track last dirt spawn position
                };
            }

            // Update cloud position
            if (game.thunderCloud) {
                game.thunderCloud.x += game.thunderCloud.speed * game.thunderCloud.direction * dt;
                game.thunderCloud.bobOffset = Math.sin(game.time * 3) * 5; // Bob in place

                // Water plants as cloud passes over them
                game.plants.forEach((plant, index) => {
                    const distFromPlant = Math.abs(game.thunderCloud.x - plant.x);

                    // Water plant when cloud is directly over it (within 60px)
                    if (distFromPlant < 60 && !game.thunderCloud.wateredPlants.includes(index)) {
                        plant.waterLevel += 40; // Add water, don't fill completely
                        if (plant.waterLevel > 100) plant.waterLevel = 100;
                        game.thunderCloud.wateredPlants.push(index);

                        // Rain particles on plant
                        for (let i = 0; i < 10; i++) {
                            game.particles.push({
                                x: plant.x + (Math.random() - 0.5) * 40,
                                y: game.thunderCloud.y + 50,
                                vy: Math.random() * 6 + 4,
                                size: Math.random() * 3 + 1,
                                alpha: 0.8,
                                color: '#64B5F6'
                            });
                        }
                    }
                });

                // Water branch when cloud passes over it
                const distFromBranch = Math.abs(game.thunderCloud.x - game.branchX);
                if (distFromBranch < 60 && !game.thunderCloud.wateredBranch) {
                    game.branchWaterLevel += 40; // Add water, don't fill completely
                    if (game.branchWaterLevel > 100) game.branchWaterLevel = 100;
                    game.thunderCloud.wateredBranch = true;

                    // Rain particles on branch
                    for (let i = 0; i < 15; i++) {
                        game.particles.push({
                            x: game.branchX + (Math.random() - 0.5) * 60,
                            y: game.thunderCloud.y + 50,
                            vy: Math.random() * 6 + 4,
                            size: Math.random() * 3 + 1,
                            alpha: 0.8,
                            color: '#64B5F6'
                        });
                    }
                }

                // Spawn dirt in cloud's wake (behind it)
                if (!game.thunderCloud.lastDirtX || Math.abs(game.thunderCloud.x - game.thunderCloud.lastDirtX) > 80) {
                    // Spawn dirt behind the cloud
                    const dirtX = game.thunderCloud.direction > 0
                        ? game.thunderCloud.x - 50  // Behind if moving right
                        : game.thunderCloud.x + 50; // Behind if moving left

                    // Only spawn if within screen bounds
                    if (dirtX > 150 && dirtX < 750) {
                        game.dirtSpots.push({
                            x: dirtX,
                            y: 200 + Math.random() * 350, // Random y position in gallery
                            size: 20 + Math.random() * 15
                        });
                        game.thunderCloud.lastDirtX = game.thunderCloud.x;
                    }
                }

                // Remove when off screen
                if (game.thunderCloud.direction > 0 && game.thunderCloud.x > canvas.width + 100) {
                    game.thunderCloud = null;
                } else if (game.thunderCloud.direction < 0 && game.thunderCloud.x < -100) {
                    game.thunderCloud = null;
                }
            }
        }

        function updateHelper(dt) {
            // Move helper to target position when game starts
            if (game.helper.moving) {
                const dx = game.helper.targetX - game.helper.x;
                const dy = game.helper.targetY - game.helper.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 5) {
                    const speed = 200;
                    game.helper.x += (dx / dist) * speed * dt;
                    game.helper.y += (dy / dist) * speed * dt;
                } else {
                    game.helper.x = game.helper.targetX;
                    game.helper.y = game.helper.targetY;
                    game.helper.moving = false;
                }
            }
        }

        function updateVisitors(dt) {
            // Spawn new visitors
            game.visitorSpawnTimer += dt;
            if (game.visitorSpawnTimer >= game.visitorSpawnInterval) {
                game.visitorSpawnTimer = 0;
                spawnVisitor();
            }

            // Update each visitor
            game.visitors.forEach((visitor, index) => {
                // Pick new target if idle
                if (!visitor.targetX || visitor.idleTimer > 2) {
                    pickNewTarget(visitor);
                    visitor.idleTimer = 0;
                }

                // Move toward target
                const dx = visitor.targetX - visitor.x;
                const dy = visitor.targetY - visitor.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 5) {
                    visitor.vx = (dx / dist) * visitor.speed;
                    visitor.vy = (dy / dist) * visitor.speed;
                    visitor.x += visitor.vx * dt;
                    visitor.y += visitor.vy * dt;

                    // Add subtle movement trail particles
                    if (Math.random() < 0.15) {
                        let trailColor;
                        if (visitor.happiness >= 70) {
                            trailColor = 'rgba(76, 175, 80, 0.4)';
                        } else if (visitor.happiness >= 40) {
                            trailColor = 'rgba(255, 235, 59, 0.4)';
                        } else {
                            trailColor = 'rgba(244, 67, 54, 0.4)';
                        }

                        game.particles.push({
                            x: visitor.x,
                            y: visitor.y + 10,
                            vy: 0.5,
                            size: 2,
                            alpha: 0.5,
                            color: trailColor
                        });
                    }
                } else {
                    visitor.vx = 0;
                    visitor.vy = 0;
                    visitor.idleTimer += dt;
                }

                // Calculate happiness based on environment
                visitor.happiness = calculateVisitorHappiness(visitor);

                // Remove visitors that are unhappy for too long
                if (visitor.happiness < 20 && visitor.idleTimer > 5) {
                    game.visitors.splice(index, 1);
                }
            });
        }

        function pickNewTarget(visitor) {
            // Intelligent AI: evaluate multiple potential targets and pick the best one
            const numCandidates = 8;
            let bestTarget = null;
            let bestScore = -999;

            for (let i = 0; i < numCandidates; i++) {
                const candidateX = 200 + Math.random() * 500;
                const candidateY = 200 + Math.random() * 350;

                // Evaluate this position's environmental quality
                let score = 0;

                // Evaluate nearby plants (INCREASED BONUSES to match happiness calc)
                game.plants.forEach(plant => {
                    const dx = plant.x - candidateX;
                    const dy = plant.y - candidateY;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 120) {
                        if (plant.growthStage === 2) {
                            score += 25; // Strongly attracted to blooming plants
                        } else if (plant.growthStage === 1) {
                            score += 15; // Moderately attracted to healthy plants (was 10)
                        } else {
                            score -= 8; // Avoid wilted plants (was -15)
                        }
                    }
                });

                // Evaluate lighting (distance from tree light)
                const distFromTree = Math.sqrt(
                    Math.pow(candidateX - game.branchX, 2) +
                    Math.pow(candidateY - game.branchY, 2)
                );

                if (distFromTree < game.treeLightRadius) {
                    if (game.treeBrightness === 1) {
                        score += 20; // Prefer normal lighting
                    } else if (game.treeBrightness === 2) {
                        score += 25; // Bright is even better
                    }
                } else if (game.treeBrightness === 0) {
                    score -= 10; // Avoid when tree light is off
                }

                // Evaluate nearby dirt (REDUCED PENALTY to match happiness calc)
                game.dirtSpots.forEach(dirt => {
                    const dx = dirt.x - candidateX;
                    const dy = dirt.y - candidateY;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 100) {
                        score -= 10; // Strongly avoid dirty areas (was -20)
                    }
                });

                // Add some randomness to avoid predictability
                score += (Math.random() - 0.5) * 10;

                // Track best candidate
                if (score > bestScore) {
                    bestScore = score;
                    bestTarget = { x: candidateX, y: candidateY };
                }
            }

            // Set target to best candidate
            if (bestTarget) {
                visitor.targetX = bestTarget.x;
                visitor.targetY = bestTarget.y;
            } else {
                // Fallback to random
                visitor.targetX = 200 + Math.random() * 500;
                visitor.targetY = 200 + Math.random() * 350;
            }
        }

        function calculateVisitorHappiness(visitor) {
            let happiness = 50; // Base happiness

            // Check nearby plants (INCREASED BONUSES)
            game.plants.forEach(plant => {
                const dx = plant.x - visitor.x;
                const dy = plant.y - visitor.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 100) {
                    if (plant.growthStage === 2) {
                        happiness += 25; // Blooming plants nearby (was 15)
                    } else if (plant.growthStage === 1) {
                        happiness += 15; // Healthy plants (was 5)
                    } else {
                        happiness -= 8; // Wilted plants (was -5)
                    }
                }
            });

            // Check distance from tree light (tree emanates light)
            const distFromTree = Math.sqrt(
                Math.pow(visitor.x - game.branchX, 2) +
                Math.pow(visitor.y - game.branchY, 2)
            );

            // Lighting bonus based on proximity to lit tree
            if (distFromTree < game.treeLightRadius) {
                if (game.treeBrightness === 1) {
                    happiness += 20; // Normal lighting is good
                } else if (game.treeBrightness === 2) {
                    happiness += 25; // Bright is even better
                }
                // No bonus when brightness is 0 (off)
            } else if (game.treeBrightness === 0) {
                happiness -= 10; // Penalty when tree light is off
            }

            // Check nearby dirt (REDUCED PENALTY)
            game.dirtSpots.forEach(dirt => {
                const dx = dirt.x - visitor.x;
                const dy = dirt.y - visitor.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 80) {
                    happiness -= 10; // Dirt nearby is bad (was -15)
                }
            });

            // Clamp happiness
            if (happiness < 0) happiness = 0;
            if (happiness > 100) happiness = 100;

            return happiness;
        }

        function evaluateEnvironment() {
            // Calculate overall environment quality
            if (game.visitors.length === 0) {
                game.overallHappiness = 50; // Neutral when no visitors
                return;
            }

            // Average visitor happiness
            const totalHappiness = game.visitors.reduce((sum, v) => sum + v.happiness, 0);
            game.overallHappiness = totalHappiness / game.visitors.length;

            // Track happiness over time
            game.happinessHistory.push(game.overallHappiness);
            if (game.happinessHistory.length > 60) {
                game.happinessHistory.shift(); // Keep last 60 samples
            }
        }

        function checkForDiscoveries() {
            // Detect when player creates good environmental combinations
            // Feynman celebrates discoveries!

            // Check for happiness spike (discovery moment)
            const happinessIncrease = game.overallHappiness - game.lastHappiness;

            // Discovery: Multiple blooming plants
            const bloomingCount = game.plants.filter(p => p.growthStage === 2).length;
            if (bloomingCount >= 4 && !game.discoveryMade.bloomingPlants) {
                game.discoveryMade.bloomingPlants = true;
                game.feynmanExcited = true;
                game.feynmanReactionTimer = 3;
                game.feynmanMessage = "Whoa! Look at all those flowers blooming! Beautiful!";
                game.messageTimer = 3;
            }

            // Discovery: Clean environment
            if (game.dirtSpots.length === 0 && !game.discoveryMade.cleanEnvironment) {
                game.discoveryMade.cleanEnvironment = true;
                game.feynmanExcited = true;
                game.feynmanReactionTimer = 3;
                game.feynmanMessage = "Spotless! A clean environment makes such a difference!";
                game.messageTimer = 3;
            }

            // Discovery: Good lighting setup
            // Discovery: Perfect lighting (normal brightness + multiple blooming plants)
            if (game.treeBrightness === 1 && bloomingCount >= 3 && !game.discoveryMade.perfectLighting) {
                game.discoveryMade.perfectLighting = true;
                game.feynmanExcited = true;
                game.feynmanReactionTimer = 3;
                game.feynmanMessage = "Perfect! Balanced lighting with healthy plants - they love it!";
                game.messageTimer = 3;
            }

            // Discovery: Synergy (everything working together)
            if (bloomingCount >= 5 && game.dirtSpots.length <= 1 && game.overallHappiness >= 85 && !game.discoveryMade.synergy) {
                game.discoveryMade.synergy = true;
                game.feynmanExcited = true;
                game.feynmanReactionTimer = 4;
                game.feynmanMessage = "AMAZING! Everything's working together! This is what I call synergy!";
                game.messageTimer = 4;
                game.screenShake = 15;

                // Extra celebration particles
                for (let i = 0; i < 50; i++) {
                    game.particles.push({
                        x: game.feynmanX + (Math.random() - 0.5) * 60,
                        y: game.feynmanY + (Math.random() - 0.5) * 60,
                        vy: Math.random() * 3 + 2,
                        size: Math.random() * 5 + 2,
                        alpha: 1,
                        color: ['#4CAF50', '#FFD700', '#FF69B4'][Math.floor(Math.random() * 3)]
                    });
                }
            }

            // General excitement from big happiness increase
            if (happinessIncrease > 20 && game.feynmanReactionTimer <= 0) {
                game.feynmanExcited = true;
                game.feynmanReactionTimer = 2;
                game.feynmanMessage = "Nice! Something you did really helped!";
                game.messageTimer = 2;
            }

            game.lastHappiness = game.overallHappiness;
        }

        function checkVictoryProgress(dt) {
            if (game.overallHappiness >= game.targetHappiness) {
                game.timeAtTargetHappiness += dt;

                if (game.timeAtTargetHappiness >= game.targetDuration) {
                    handleVictory();
                }
            } else {
                game.timeAtTargetHappiness = 0; // Reset if happiness drops
            }
        }

        function checkGameOver() {
            // Game over if we have visitors and ALL of them are unhappy (happiness < 20)
            if (game.visitors.length >= 3) {
                const allSad = game.visitors.every(v => v.happiness < 20);
                if (allSad && !game.gameOverState) {
                    console.log('GAME OVER - All visitors are sad!');
                    game.gameOverState = true;
                    game.gameOverTimer = 0;
                    game.skullScale = 0;
                    game.skullAlpha = 0;
                    return;
                }
            }

            // Game over if happiness hits rock bottom (< 10)
            if (game.overallHappiness < 10 && game.visitors.length > 0 && !game.gameOverState) {
                console.log('GAME OVER - Happiness rock bottom!');
                game.gameOverState = true;
                game.gameOverTimer = 0;
                game.skullScale = 0;
                game.skullAlpha = 0;
                return;
            }

            // Game over if time runs out with low happiness (< 60%)
            if (game.timeRemaining <= 0 && game.overallHappiness < 60 && !game.gameOverState) {
                console.log('GAME OVER - Time ran out with low happiness!');
                game.gameOverState = true;
                game.gameOverTimer = 0;
                game.skullScale = 0;
                game.skullAlpha = 0;
                return;
            }
        }

        function handleVictory() {
            console.log('VICTORY!');
            game.victoryState = true;
            game.victoryTimer = 0;

            game.feynmanMessage = 'AMAZING! You created a thriving environment!';
            game.messageTimer = 999;
            game.feynmanExcited = true;

            // Generate confetti
            for (let i = 0; i < 200; i++) {
                game.confetti.push({
                    x: Math.random() * canvas.width,
                    y: -20 - Math.random() * 100,
                    vx: (Math.random() - 0.5) * 4,
                    vy: Math.random() * 3 + 2,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.2,
                    size: Math.random() * 10 + 5,
                    color: ['#4CAF50', '#8BC34A', '#CDDC39', '#66BB6A', '#81C784'][Math.floor(Math.random() * 5)],
                    alpha: 1
                });
            }
        }

        // Update loop
        function update(dt) {
            if (game.paused) return;
            if (!game.gameStarted) return;

            game.time += dt;

            if (game.messageTimer > 0) {
                game.messageTimer -= dt;
            }

            // Screen shake decay
            if (game.screenShake > 0) {
                game.screenShake *= 0.85;
                if (game.screenShake < 0.1) game.screenShake = 0;
            }

            // Game over state updates
            if (game.gameOverState) {
                game.gameOverTimer += dt;

                // Animate skull zoom out and fade in
                if (game.skullScale < 1) {
                    game.skullScale += dt * 0.5; // Zoom from 0 to 1
                    if (game.skullScale > 1) game.skullScale = 1;
                }
                if (game.skullAlpha < 1) {
                    game.skullAlpha += dt * 0.7; // Fade in
                    if (game.skullAlpha > 1) game.skullAlpha = 1;
                }

                return; // Skip normal updates during game over
            }

            // Victory state updates
            if (game.victoryState) {
                game.victoryTimer += dt;

                // Update confetti
                game.confetti.forEach((c, i) => {
                    c.x += c.vx;
                    c.y += c.vy;
                    c.vy += 0.15; // gravity
                    c.rotation += c.rotationSpeed;

                    if (c.y > canvas.height + 50) {
                        game.confetti.splice(i, 1);
                    }
                });

                return; // Skip normal updates during victory
            }

            // Update game systems
            game.timeRemaining -= dt;

            // Prevent time from going negative
            if (game.timeRemaining < 0) {
                game.timeRemaining = 0;
            }

            updatePlants(dt);
            updateBranchAura(dt);
            updateLighting(dt);
            updateDirt(dt);
            updateChicken(dt);
            updateThunderCloud(dt);
            updateHelper(dt);
            updateVisitors(dt);
            evaluateEnvironment();

            // Bonus time for happiness increases (very incremental)
            if (game.overallHappiness > game.lastHappinessForBonus + 5 && game.timeRemaining < game.maxTime) {
                // Very small time bonus (0.5 seconds) for every 5 points of happiness increase
                game.timeRemaining += 0.5;
                if (game.timeRemaining > game.maxTime) game.timeRemaining = game.maxTime;
                game.lastHappinessForBonus = game.overallHappiness;
            } else if (game.overallHappiness < game.lastHappinessForBonus - 5) {
                // Update baseline if happiness drops
                game.lastHappinessForBonus = game.overallHappiness;
            }

            checkForDiscoveries();
            checkVictoryProgress(dt);
            checkGameOver();

            // Update Feynman reaction timer
            if (game.feynmanReactionTimer > 0) {
                game.feynmanReactionTimer -= dt;
                if (game.feynmanReactionTimer <= 0) {
                    game.feynmanExcited = false;
                }
            }

            // Update particles
            game.particles.forEach((p, i) => {
                p.y -= p.vy;
                p.alpha -= 0.02;
                if (p.alpha <= 0) game.particles.splice(i, 1);
            });
        }

        // Render loop
        function render() {
            // Apply screen shake
            ctx.save();
            if (game.screenShake > 0) {
                const shakeX = (Math.random() - 0.5) * game.screenShake;
                const shakeY = (Math.random() - 0.5) * game.screenShake;
                ctx.translate(shakeX, shakeY);
            }

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw start screen or game
            if (!game.gameStarted && !game.tutorialStarted) {
                drawStartScreen();
            } else {
                drawGame();
            }

            ctx.restore();
        }

        function drawStartScreen() {
            // Title with light shadow
            ctx.textAlign = 'center';
            ctx.font = 'bold 48px Caveat, cursive';

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillText('Living Gallery', canvas.width / 2 + 2, canvas.height / 2 - 98);

            // Title text
            ctx.fillStyle = '#2E7D32';
            ctx.fillText('Living Gallery', canvas.width / 2, canvas.height / 2 - 100);

            // Subtitle with light shadow
            ctx.font = '24px Caveat, cursive';

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.12)';
            ctx.fillText('Feynman\'s Environmental Challenge', canvas.width / 2 + 1, canvas.height / 2 - 49);

            // Subtitle text
            ctx.fillStyle = '#666';
            ctx.fillText('Feynman\'s Environmental Challenge', canvas.width / 2, canvas.height / 2 - 50);

            // Start button with hover effects
            const btnX = canvas.width / 2 - 100;
            const btnY = canvas.height / 2;
            const btnW = 200;
            const btnH = 60;

            // Hover animation: scale and glow
            const scale = game.startButtonHover ? 1.05 : 1;
            const scaledW = btnW * scale;
            const scaledH = btnH * scale;
            const scaledX = btnX - (scaledW - btnW) / 2;
            const scaledY = btnY - (scaledH - btnH) / 2;

            // Glow effect
            if (game.startButtonHover) {
                ctx.shadowColor = '#4CAF50';
                ctx.shadowBlur = 20;
            }

            // Button gradient
            const gradient = ctx.createLinearGradient(scaledX, scaledY, scaledX, scaledY + scaledH);
            gradient.addColorStop(0, game.startButtonHover ? '#66BB6A' : '#81C784');
            gradient.addColorStop(1, game.startButtonHover ? '#4CAF50' : '#66BB6A');

            ctx.fillStyle = gradient;
            ctx.strokeStyle = '#2E7D32';
            ctx.lineWidth = 4;
            roundRect(ctx, scaledX, scaledY, scaledW, scaledH, 10);
            ctx.fill();
            ctx.stroke();

            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;

            // Text
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 28px Caveat, cursive';
            ctx.fillText('Start', canvas.width / 2, canvas.height / 2 + 40);

            // Tutorial messages during startup
            if (game.messageTimer > 0 && game.feynmanMessage) {
                drawFeynmanMessage();
            }
        }

        function drawGame() {
            // Draw light aura from tree (emanates from center)
            if (game.treeBrightness > 0) {
                const pulse = 0.8 + Math.sin(game.time * 1.5) * 0.2;
                const radius = game.treeLightRadius * pulse;

                let lightColor;
                if (game.treeBrightness === 1) {
                    lightColor = 'rgba(255, 255, 200, 0.15)'; // Normal (soft yellow glow)
                } else if (game.treeBrightness === 2) {
                    lightColor = 'rgba(255, 255, 150, 0.25)'; // Bright (strong yellow glow)
                }

                const gradient = ctx.createRadialGradient(
                    game.branchX, game.branchY, 0,
                    game.branchX, game.branchY, radius
                );
                gradient.addColorStop(0, lightColor);
                gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(game.branchX, game.branchY, radius, 0, Math.PI * 2);
                ctx.fill();

                // Flash effect when lighting changes
                if (game.lightFlashTimer > 0) {
                    const flashAlpha = game.lightFlashTimer * 0.6;
                    const flashGradient = ctx.createRadialGradient(
                        game.branchX, game.branchY, 0,
                        game.branchX, game.branchY, radius
                    );
                    flashGradient.addColorStop(0, `rgba(255, 215, 0, ${flashAlpha})`);
                    flashGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                    ctx.fillStyle = flashGradient;
                    ctx.beginPath();
                    ctx.arc(game.branchX, game.branchY, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw central branch (anchor of the game)
            drawBranch();

            // Draw plants
            game.plants.forEach(plant => {
                drawPlant(plant);
            });

            // Draw dirt
            game.dirtSpots.forEach(dirt => {
                drawDirt(dirt);
            });

            // Draw visitors
            game.visitors.forEach(visitor => {
                drawVisitor(visitor);
            });

            // Draw surprise elements
            if (game.chicken) {
                drawChicken();
            }
            if (game.thunderCloud) {
                drawThunderCloud();
            }

            // Draw particles
            game.particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.alpha;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });

            // Draw confetti (victory)
            game.confetti.forEach(c => {
                ctx.save();
                ctx.translate(c.x, c.y);
                ctx.rotate(c.rotation);
                ctx.fillStyle = c.color;
                ctx.globalAlpha = c.alpha;
                ctx.fillRect(-c.size/2, -c.size/2, c.size, c.size);
                ctx.globalAlpha = 1;
                ctx.restore();
            });

            // Draw UI
            drawToolbar();
            drawHUD();
            drawFeynmanNPC();

            if (game.messageTimer > 0 && game.feynmanMessage) {
                drawFeynmanMessage();
            }

            // Draw Groot popup (when all plants fully watered)
            if (game.grootPopup && game.grootPopupTimer < 3) {
                drawGrootPopup();
            }

            // Draw pause overlay
            if (game.paused && !game.victoryState) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.textAlign = 'center';
                ctx.font = 'bold 60px Caveat, cursive';
                ctx.fillStyle = '#81C784';
                ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);

                ctx.font = 'bold 24px Caveat, cursive';
                ctx.fillStyle = '#FFF';
                ctx.fillText('Click anywhere to resume', canvas.width / 2, canvas.height / 2 + 50);
            }

            // Draw game over screen
            if (game.gameOverState) {
                drawGameOverScreen();
            }

            // Draw victory screen
            if (game.victoryState) {
                drawVictoryScreen();
            }
        }

        function drawPlant(plant) {
            const baseX = plant.x;
            const baseY = plant.y;

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(baseX, baseY + 35, 15, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Plant stem and leaves
            if (plant.growthStage === 0) {
                // Wilted (brown)
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(baseX, baseY + 30);
                ctx.lineTo(baseX - 5, baseY + 10);
                ctx.stroke();
            } else if (plant.growthStage === 1) {
                // Healthy (green)
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(baseX, baseY + 30);
                ctx.lineTo(baseX, baseY);
                ctx.stroke();

                // Leaves
                ctx.fillStyle = '#66BB6A';
                ctx.beginPath();
                ctx.ellipse(baseX - 10, baseY + 15, 8, 12, -0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(baseX + 10, baseY + 15, 8, 12, 0.3, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Blooming (green + flowers + glow)

                // Glow effect for blooming plants
                const glowPulse = 0.5 + Math.sin(game.time * 2 + plant.id) * 0.3;
                const gradient = ctx.createRadialGradient(baseX, baseY - 5, 0, baseX, baseY - 5, 40);
                gradient.addColorStop(0, `rgba(255, 215, 0, ${glowPulse * 0.4})`);
                gradient.addColorStop(0.5, `rgba(255, 182, 193, ${glowPulse * 0.2})`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(baseX, baseY - 5, 40, 0, Math.PI * 2);
                ctx.fill();

                // Stem
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(baseX, baseY + 30);
                ctx.lineTo(baseX, baseY - 5);
                ctx.stroke();

                // Leaves with subtle gradient
                const leafGradient = ctx.createRadialGradient(baseX, baseY + 15, 0, baseX, baseY + 15, 15);
                leafGradient.addColorStop(0, '#81C784');
                leafGradient.addColorStop(1, '#66BB6A');
                ctx.fillStyle = leafGradient;
                ctx.beginPath();
                ctx.ellipse(baseX - 12, baseY + 15, 10, 14, -0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(baseX + 12, baseY + 15, 10, 14, 0.3, 0, Math.PI * 2);
                ctx.fill();

                // Flowers with glow
                for (let i = 0; i < 3; i++) {
                    const flowerX = baseX + (i - 1) * 8;
                    const flowerY = baseY - 5;
                    const flowerColors = ['#FF69B4', '#FFD700', '#FF6347'];

                    // Flower glow
                    ctx.shadowColor = flowerColors[i];
                    ctx.shadowBlur = 8;

                    ctx.fillStyle = flowerColors[i];
                    ctx.beginPath();
                    ctx.arc(flowerX, flowerY, 5, 0, Math.PI * 2);
                    ctx.fill();

                    // Flower center
                    ctx.fillStyle = '#FFE082';
                    ctx.beginPath();
                    ctx.arc(flowerX, flowerY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;

                // Sparkle particles around blooming plants
                if (Math.random() < 0.1) {
                    game.particles.push({
                        x: baseX + (Math.random() - 0.5) * 30,
                        y: baseY - 10 + (Math.random() - 0.5) * 20,
                        vy: Math.random() * 1 + 0.5,
                        size: Math.random() * 2 + 1,
                        alpha: 1,
                        color: '#FFD700'
                    });
                }
            }

            // Water level indicator (small bar below plant)
            const barW = 30;
            const barH = 4;
            const barX = baseX - barW / 2;
            const barY = baseY + 40;

            ctx.fillStyle = '#DDD';
            ctx.fillRect(barX, barY, barW, barH);

            const waterColor = plant.waterLevel < 30 ? '#F44336' : '#2196F3';
            ctx.fillStyle = waterColor;
            ctx.fillRect(barX, barY, (plant.waterLevel / 100) * barW, barH);

            // Watering animation
            if (plant.wateringAnimation > 0) {
                for (let i = 0; i < 5; i++) {
                    const dropX = baseX + (Math.random() - 0.5) * 20;
                    const dropY = baseY - 20 + Math.random() * 20;
                    ctx.fillStyle = 'rgba(33, 150, 243, 0.6)';
                    ctx.beginPath();
                    ctx.arc(dropX, dropY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawDirt(dirt) {
            ctx.fillStyle = 'rgba(101, 67, 33, 0.5)';
            ctx.beginPath();
            ctx.arc(dirt.x, dirt.y, dirt.size, 0, Math.PI * 2);
            ctx.fill();

            // Add some texture
            for (let i = 0; i < 5; i++) {
                const spotX = dirt.x + (Math.random() - 0.5) * dirt.size;
                const spotY = dirt.y + (Math.random() - 0.5) * dirt.size;
                ctx.fillStyle = 'rgba(80, 50, 20, 0.4)';
                ctx.beginPath();
                ctx.arc(spotX, spotY, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawVisitor(visitor) {
            const bob = Math.sin(game.time * 3 + visitor.id) * 2;
            const visX = visitor.x;
            const visY = visitor.y + bob;

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(visX, visitor.y + 30, 15, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Happiness glow
            const glowSize = 25 + visitor.happiness / 5;
            const gradient = ctx.createRadialGradient(visX, visY, 0, visX, visY, glowSize);

            let glowColor;
            if (visitor.happiness >= 70) {
                glowColor = 'rgba(76, 175, 80, 0.4)'; // Green (happy)
            } else if (visitor.happiness >= 40) {
                glowColor = 'rgba(255, 235, 59, 0.4)'; // Yellow (neutral)
            } else {
                glowColor = 'rgba(244, 67, 54, 0.4)'; // Red (unhappy)
            }

            gradient.addColorStop(0, glowColor);
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(visX, visY, glowSize, 0, Math.PI * 2);
            ctx.fill();

            // Draw visitor sprite (use stick_sad if unhappy, otherwise use assigned sprite)
            let spriteKey = visitor.sprite;
            if (visitor.happiness < 40 && game.images.stick_sad && game.images.stick_sad.complete) {
                spriteKey = 'stick_sad';
            }

            if (game.imagesLoaded && spriteKey && game.images[spriteKey] && game.images[spriteKey].complete) {
                const visWidth = 50;
                const visHeight = 60;
                ctx.drawImage(
                    game.images[spriteKey],
                    visX - visWidth / 2,
                    visY - visHeight / 2,
                    visWidth,
                    visHeight
                );
            } else {
                // Fallback: simple stick figure
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;

                // Head
                ctx.fillStyle = '#FFE0BD';
                ctx.beginPath();
                ctx.arc(visX, visY - 10, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Body
                ctx.beginPath();
                ctx.moveTo(visX, visY - 2);
                ctx.lineTo(visX, visY + 15);
                ctx.stroke();

                // Arms
                ctx.beginPath();
                ctx.moveTo(visX - 8, visY + 5);
                ctx.lineTo(visX + 8, visY + 5);
                ctx.stroke();

                // Legs
                ctx.beginPath();
                ctx.moveTo(visX, visY + 15);
                ctx.lineTo(visX - 6, visY + 25);
                ctx.moveTo(visX, visY + 15);
                ctx.lineTo(visX + 6, visY + 25);
                ctx.stroke();
            }
        }

        function drawChicken() {
            if (!game.chicken || !game.imagesLoaded) return;

            const img = game.images[game.chicken.type];
            if (!img || !img.complete) return;

            // Draw with slight bob
            const bob = Math.sin(game.time * 5) * 3;
            const size = game.chicken.size;

            ctx.drawImage(
                img,
                game.chicken.x - size / 2,
                game.chicken.y - size / 2 + bob,
                size,
                size
            );
        }

        function drawThunderCloud() {
            if (!game.thunderCloud || !game.imagesLoaded) return;

            const img = game.images.thunder_cloud;
            if (!img || !img.complete) return;

            const cloudSize = 100;
            const x = game.thunderCloud.x;
            const y = game.thunderCloud.y + game.thunderCloud.bobOffset;

            // Draw cloud
            ctx.drawImage(
                img,
                x - cloudSize / 2,
                y - cloudSize / 2,
                cloudSize,
                cloudSize
            );

            // Lightning flash when raining
            if (Math.abs(game.thunderCloud.x - canvas.width / 2) < 150) {
                if (Math.random() < 0.3) {
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.moveTo(x, y + 30);
                    ctx.lineTo(x - 10, y + 50);
                    ctx.lineTo(x + 5, y + 50);
                    ctx.lineTo(x - 5, y + 70);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            }
        }

        function drawToolbar() {
            // Tool selection buttons (left side)
            game.toolButtons.forEach(btn => {
                const isSelected = game.currentTool === btn.tool;

                // Check if mouse is hovering over this button
                const isHovered = game.mouseX >= btn.x && game.mouseX <= btn.x + btn.w &&
                                  game.mouseY >= btn.y && game.mouseY <= btn.y + btn.h;

                // Hover animation: scale and glow
                const scale = isHovered ? 1.05 : 1;
                const scaledW = btn.w * scale;
                const scaledH = btn.h * scale;
                const scaledX = btn.x - (scaledW - btn.w) / 2;
                const scaledY = btn.y - (scaledH - btn.h) / 2;

                // Glow effect on hover
                if (isHovered) {
                    ctx.shadowColor = isSelected ? '#2E7D32' : '#4CAF50';
                    ctx.shadowBlur = 15;
                }

                ctx.fillStyle = isSelected ? '#4CAF50' : 'rgba(255, 255, 255, 0.9)';
                ctx.strokeStyle = isSelected ? '#2E7D32' : '#CCC';
                ctx.lineWidth = isSelected ? 4 : 2;
                roundRect(ctx, scaledX, scaledY, scaledW, scaledH, 8);
                ctx.fill();
                ctx.stroke();

                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;

                ctx.font = '28px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(btn.icon, btn.x + btn.w / 2, btn.y + 35);

                ctx.font = 'bold 11px Caveat, cursive';
                ctx.fillStyle = '#333';
                ctx.fillText(btn.label, btn.x + btn.w / 2, btn.y + 52);
            });

            // Tree brightness controls (only show when light tool selected)
            if (game.currentTool === 'light') {
                const controlX = 20;
                const controlY = 340;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                roundRect(ctx, controlX, controlY, 80, 90, 8);
                ctx.fill();
                ctx.stroke();

                ctx.font = 'bold 12px Caveat, cursive';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#333';
                ctx.fillText('Tree Light', controlX + 40, controlY + 20);

                // Brightness buttons
                const brightnessLabels = ['Off', 'On', 'Max'];
                brightnessLabels.forEach((label, b) => {
                    const btnX = controlX + 5 + (b * 28);
                    const btnY = controlY + 35;
                    const btnW = 25;
                    const btnH = 25;

                    // Hover effect
                    const isHovering = game.mouseX >= btnX && game.mouseX <= btnX + btnW &&
                                      game.mouseY >= btnY && game.mouseY <= btnY + btnH;

                    ctx.fillStyle = game.treeBrightness === b ? '#FFD700' : (isHovering ? '#FFF' : '#EEE');
                    ctx.strokeStyle = game.treeBrightness === b ? '#FFA500' : '#999';
                    ctx.lineWidth = game.treeBrightness === b ? 2 : 1;
                    ctx.fillRect(btnX, btnY, btnW, btnH);
                    ctx.strokeRect(btnX, btnY, btnW, btnH);

                    ctx.font = '9px Caveat, cursive';
                    ctx.fillStyle = '#333';
                    ctx.fillText(b.toString(), btnX + btnW / 2, btnY + btnH / 2 + 3);
                });

                // Label
                ctx.font = '9px Caveat, cursive';
                ctx.fillStyle = '#666';
                ctx.fillText('(Brightness from tree)', controlX + 40, controlY + 75);
            }
        }

        function drawHUD() {
            // Timer display (top left) with alarm icon
            const timerX = 120;
            const timerY = 20;
            const timerW = 120;
            const timerH = 40;

            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            roundRect(ctx, timerX, timerY, timerW, timerH, 6);
            ctx.fill();
            ctx.stroke();

            // Alarm icon
            if (game.imagesLoaded && game.images.alarm && game.images.alarm.complete) {
                const alarmSize = 25;
                ctx.drawImage(
                    game.images.alarm,
                    timerX + 8,
                    timerY + (timerH - alarmSize) / 2,
                    alarmSize,
                    alarmSize
                );
            }

            // Time text (countdown)
            const minutes = Math.floor(game.timeRemaining / 60);
            const seconds = Math.floor(game.timeRemaining % 60);
            ctx.font = 'bold 20px Caveat, cursive';
            ctx.textAlign = 'center';

            // Red text if time is running out (< 1 minute)
            if (game.timeRemaining < 60) {
                ctx.fillStyle = '#F44336';
            } else if (game.timeRemaining < 120) {
                ctx.fillStyle = '#FF9800'; // Orange warning
            } else {
                ctx.fillStyle = '#333';
            }

            ctx.fillText(`${minutes}:${seconds.toString().padStart(2, '0')}`, timerX + timerW / 2 + 15, timerY + 26);

            // Top center: Progress bar for victory condition
            const barX = 250;
            const barY = 20;
            const barW = 400;
            const barH = 30;

            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            roundRect(ctx, barX, barY, barW, barH, 8);
            ctx.fill();
            ctx.stroke();

            // Happiness level
            const happinessPercent = game.overallHappiness / 100;
            let barColor;
            if (game.overallHappiness >= 80) {
                barColor = '#4CAF50';
            } else if (game.overallHappiness >= 50) {
                barColor = '#FFEB3B';
            } else {
                barColor = '#F44336';
            }

            ctx.fillStyle = barColor;
            ctx.fillRect(barX + 2, barY + 2, (barW - 4) * happinessPercent, barH - 4);

            // Text
            ctx.font = 'bold 14px Caveat, cursive';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#333';
            ctx.fillText(`Happiness: ${Math.round(game.overallHappiness)}%`, barX + barW / 2, barY + 20);

            // Victory progress (time at target)
            if (game.overallHappiness >= game.targetHappiness) {
                const progressY = barY + 35;
                const progressW = 400;
                const progressH = 20;

                ctx.fillStyle = 'rgba(76, 175, 80, 0.3)';
                roundRect(ctx, barX, progressY, progressW, progressH, 6);
                ctx.fill();

                const timePercent = game.timeAtTargetHappiness / game.targetDuration;
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(barX + 2, progressY + 2, (progressW - 4) * timePercent, progressH - 4);

                ctx.font = 'bold 12px Caveat, cursive';
                ctx.fillStyle = '#2E7D32';
                const mins = Math.floor(game.timeAtTargetHappiness / 60);
                const secs = Math.floor(game.timeAtTargetHappiness % 60);
                ctx.fillText(`Victory Progress: ${mins}:${secs.toString().padStart(2, '0')} / 3:00`, barX + progressW / 2, progressY + 14);
            }

            // Restart button (upper left)
            const restartBtnCanvasX = 20;
            const restartBtnCanvasY = 20;
            const restartBtnCanvasW = 60;
            const restartBtnCanvasH = 50;

            // Check hover
            const restartHovered = game.mouseX >= restartBtnCanvasX && game.mouseX <= restartBtnCanvasX + restartBtnCanvasW &&
                                   game.mouseY >= restartBtnCanvasY && game.mouseY <= restartBtnCanvasY + restartBtnCanvasH;

            // Hover animation
            const restartScale = restartHovered ? 1.08 : 1;
            const restartScaledW = restartBtnCanvasW * restartScale;
            const restartScaledH = restartBtnCanvasH * restartScale;
            const restartScaledX = restartBtnCanvasX - (restartScaledW - restartBtnCanvasW) / 2;
            const restartScaledY = restartBtnCanvasY - (restartScaledH - restartBtnCanvasH) / 2;

            // Glow on hover
            if (restartHovered) {
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 15;
            }

            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 3;
            roundRect(ctx, restartScaledX, restartScaledY, restartScaledW, restartScaledH, 10);
            ctx.fill();
            ctx.stroke();

            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;

            // Restart icon (circular arrow)
            const centerX = restartBtnCanvasX + restartBtnCanvasW / 2;
            const centerY = restartBtnCanvasY + restartBtnCanvasH / 2;
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 12, 0.5, Math.PI * 2 - 0.5);
            ctx.stroke();

            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.moveTo(centerX + 12, centerY - 3);
            ctx.lineTo(centerX + 12, centerY + 5);
            ctx.lineTo(centerX + 18, centerY);
            ctx.closePath();
            ctx.fill();

            game.restartButtonCanvasBounds = {
                x: restartBtnCanvasX,
                y: restartBtnCanvasY,
                w: restartBtnCanvasW,
                h: restartBtnCanvasH
            };

            // Pause button (upper right)
            const pauseBtnX = canvas.width - 80;
            const pauseBtnY = 20;
            const pauseBtnW = 60;
            const pauseBtnH = 50;

            // Check hover
            const pauseHovered = game.mouseX >= pauseBtnX && game.mouseX <= pauseBtnX + pauseBtnW &&
                                 game.mouseY >= pauseBtnY && game.mouseY <= pauseBtnY + pauseBtnH;

            // Hover animation
            const pauseScale = pauseHovered ? 1.08 : 1;
            const pauseScaledW = pauseBtnW * pauseScale;
            const pauseScaledH = pauseBtnH * pauseScale;
            const pauseScaledX = pauseBtnX - (pauseScaledW - pauseBtnW) / 2;
            const pauseScaledY = pauseBtnY - (pauseScaledH - pauseBtnH) / 2;

            // Glow on hover
            if (pauseHovered) {
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 15;
            }

            ctx.fillStyle = game.paused ? '#4CAF50' : 'rgba(0, 0, 0, 0.6)';
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 3;
            roundRect(ctx, pauseScaledX, pauseScaledY, pauseScaledW, pauseScaledH, 10);
            ctx.fill();
            ctx.stroke();

            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#FFF';
            if (game.paused) {
                // Play triangle
                ctx.beginPath();
                ctx.moveTo(pauseBtnX + 20, pauseBtnY + 12);
                ctx.lineTo(pauseBtnX + 20, pauseBtnY + 38);
                ctx.lineTo(pauseBtnX + 45, pauseBtnY + 25);
                ctx.closePath();
                ctx.fill();
            } else {
                // Pause bars
                ctx.fillRect(pauseBtnX + 18, pauseBtnY + 12, 8, 26);
                ctx.fillRect(pauseBtnX + 34, pauseBtnY + 12, 8, 26);
            }

            game.pauseButtonBounds = {
                x: pauseBtnX,
                y: pauseBtnY,
                w: pauseBtnW,
                h: pauseBtnH
            };
        }

        function drawBranch() {
            const x = game.branchX;
            const y = game.branchY;

            // Check tree brightness (no zones, light emanates from tree itself)
            const branchInDarkness = game.treeBrightness === 0;
            const branchInLight = game.treeBrightness >= 1;

            // Check if any plant is fully watered for Groot to appear
            const isPerfect = game.plants.some(p => p.waterLevel >= 95);

            // Pulsing aura that indicates game state
            const pulse = 0.7 + Math.sin(game.time * 2) * 0.3;
            let auraSize = 80 + pulse * 20;

            // Grey aura spreads when in darkness
            if (branchInDarkness) {
                auraSize = 120 + pulse * 30; // Larger spreading aura
            }

            // Golden glow when perfect (Groot conditions)
            if (isPerfect) {
                auraSize = 100 + pulse * 25;
                const grootGradient = ctx.createRadialGradient(x, y, 0, x, y, auraSize);
                grootGradient.addColorStop(0, 'rgba(76, 175, 80, 0.6)');
                grootGradient.addColorStop(0.5, 'rgba(129, 199, 132, 0.3)');
                grootGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = grootGradient;
                ctx.beginPath();
                ctx.arc(x, y, auraSize, 0, Math.PI * 2);
                ctx.fill();
            } else {
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, auraSize);
                gradient.addColorStop(0, game.branchAuraColor);
                gradient.addColorStop(0.6, game.branchAuraColor.replace('0.7', '0.3').replace('0.6', '0.25').replace('0.5', '0.2').replace('0.4', '0.15'));
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, auraSize, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw Branch (Groot only appears as popup, not branch transformation)
            if (game.imagesLoaded && game.images.branch && game.images.branch.complete) {
                // Draw regular branch
                const branchWidth = 120;
                const branchHeight = 100;

                // Shadow - darker and larger when branch needs water
                const shadowAlpha = game.branchWaterLevel < 30 ? 0.6 : 0.3;
                const shadowSize = game.branchWaterLevel < 30 ? 60 : 50;
                ctx.fillStyle = `rgba(0, 0, 0, ${shadowAlpha})`;
                ctx.beginPath();
                ctx.ellipse(x, y + 60, shadowSize, 12, 0, 0, Math.PI * 2);
                ctx.fill();

                // Branch color tint only when dry
                if (game.branchWaterLevel < 30) {
                    // Dry - darker/brownish tint
                    ctx.globalAlpha = 0.4;
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(x - branchWidth / 2, y - branchHeight / 2, branchWidth, branchHeight);
                    ctx.globalAlpha = 1;
                }

                ctx.drawImage(
                    game.images.branch,
                    x - branchWidth / 2,
                    y - branchHeight / 2,
                    branchWidth,
                    branchHeight
                );

                // Aura message (only for branch, not Groot)
                if (game.branchAuraMessage) {
                    ctx.textAlign = 'center';
                    ctx.font = 'bold 12px Caveat, cursive';
                    ctx.fillStyle = '#333';
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 3;
                    ctx.strokeText(game.branchAuraMessage, x, y + 70);
                    ctx.fillText(game.branchAuraMessage, x, y + 70);
                }
            }
        }

        function drawGrootPopup() {
            // Start from branch position, zoom out as reward
            if (game.imagesLoaded && game.images.groot && game.images.groot.complete) {
                const grootSize = 200 * game.grootPopupScale;

                // Sprite layout: Groot character on left, "i am groot" text on right
                // To center the Groot character, shift entire sprite right by 1/3
                const spriteX = game.branchX + grootSize / 3;
                const spriteY = game.branchY;

                ctx.globalAlpha = game.grootPopupAlpha;

                // Glow effect centered on branch (where Groot appears from)
                const gradient = ctx.createRadialGradient(game.branchX, game.branchY, 0, game.branchX, game.branchY, grootSize / 2);
                gradient.addColorStop(0, 'rgba(76, 175, 80, 0.6)');
                gradient.addColorStop(0.5, 'rgba(129, 199, 132, 0.3)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(game.branchX, game.branchY, grootSize / 2, 0, Math.PI * 2);
                ctx.fill();

                // Draw groot sprite - shift right by 1/3 to center Groot character
                ctx.drawImage(
                    game.images.groot,
                    spriteX - grootSize / 2,
                    spriteY - grootSize / 2,
                    grootSize,
                    grootSize
                );

                ctx.globalAlpha = 1;
            }
        }

        function drawFeynmanNPC() {
            // Use helper position when game started, otherwise use fixed Feynman position
            const x = game.gameStarted ? game.helper.x : game.feynmanX;
            const y = game.gameStarted ? game.helper.y : game.feynmanY;

            // Animation: gentle bobbing when idle, excited bounce when celebrating
            let offsetY = 0;
            let offsetX = 0;
            if (game.feynmanExcited) {
                // Excited bounce
                offsetY = Math.sin(game.time * 8) * 8;
                offsetX = Math.sin(game.time * 10) * 3;
            } else {
                // Gentle idle sway
                offsetY = Math.sin(game.time * 1.5) * 3;
                offsetX = Math.sin(game.time * 2) * 2;
            }

            // Draw Feynman using stick_mustache (or helper during movement)
            if (game.imagesLoaded && game.images.stick_mustache && game.images.stick_mustache.complete) {
                const feynmanWidth = 60;
                const feynmanHeight = 70;

                ctx.drawImage(
                    game.images.stick_mustache,
                    x - feynmanWidth / 2 + offsetX,
                    y - feynmanHeight / 2 + offsetY,
                    feynmanWidth,
                    feynmanHeight
                );
            } else {
                // Fallback: simple representation
                ctx.fillStyle = '#FFE0BD';
                ctx.beginPath();
                ctx.arc(x + offsetX, y + offsetY, 20, 0, Math.PI * 2);
                ctx.fill();

                // Glasses
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x - 8 + offsetX, y + offsetY, 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(x + 8 + offsetX, y + offsetY, 5, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw helper (stick_hands_hip) closer to center during tutorial
            if (!game.gameStarted && game.imagesLoaded && game.images.stick_hands_hip && game.images.stick_hands_hip.complete) {
                const helperBob = Math.sin(game.time * 2) * 5;
                const helperWidth = 63;  // 1.25x larger than 50
                const helperHeight = 75; // 1.25x larger than 60

                // Move figure to the right by its own width during tutorial
                const tutorialOffset = !game.tutorialComplete ? 63 : 0;

                ctx.drawImage(
                    game.images.stick_hands_hip,
                    game.helper.x - helperWidth / 2 + tutorialOffset,
                    game.helper.y - helperHeight / 2 + helperBob,
                    helperWidth,
                    helperHeight
                );
            }
        }

        function drawFeynmanMessage() {
            const msgW = 500;
            const msgH = 100;
            const msgX = canvas.width / 2 - msgW / 2;
            const msgY = canvas.height / 2 - msgH / 2;
            const padding = 20;

            // Store bounds for click detection
            game.tutorialMessageBounds = { x: msgX, y: msgY, w: msgW, h: msgH };

            // Semi-transparent box (no border)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
            roundRect(ctx, msgX, msgY, msgW, msgH, 8);
            ctx.fill();

            // Text
            ctx.font = 'bold 18px Caveat, cursive';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#333';
            wrapText(ctx, game.feynmanMessage, msgX + msgW / 2, msgY + padding + 10, msgW - padding * 2, 24);
        }

        function drawVictoryScreen() {
            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(46, 125, 50, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Victory text with pulsating effect and glow
            ctx.textAlign = 'center';

            // Pulsating scale
            const textPulse = 1 + Math.sin(game.time * 2) * 0.05;
            const fontSize = 60 * textPulse;
            ctx.font = `bold ${fontSize}px Caveat, cursive`;

            // Glow effect
            ctx.shadowColor = '#81C784';
            ctx.shadowBlur = 20 + Math.sin(game.time * 3) * 10;

            ctx.strokeStyle = '#1B5E20';
            ctx.lineWidth = 8;
            ctx.fillStyle = '#81C784';
            ctx.strokeText('LEVEL COMPLETE!', canvas.width / 2, canvas.height / 2 - 100);
            ctx.fillText('LEVEL COMPLETE!', canvas.width / 2, canvas.height / 2 - 100);

            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;

            ctx.font = 'bold 28px Caveat, cursive';
            ctx.fillStyle = '#FFF';
            ctx.fillText('You created a thriving environment!', canvas.width / 2, canvas.height / 2 - 40);

            // Stats
            ctx.font = 'bold 20px Caveat, cursive';
            ctx.fillText(`Final Happiness: ${Math.round(game.overallHappiness)}%`, canvas.width / 2, canvas.height / 2 + 10);
            ctx.fillText(`Visitors Served: ${game.visitors.length}`, canvas.width / 2, canvas.height / 2 + 40);

            // Pulsating Restart Button
            const restartBtnX = canvas.width / 2 - 100;
            const restartBtnY = canvas.height / 2 + 80;
            const restartBtnW = 200;
            const restartBtnH = 60;

            // Pulsating scale effect
            const pulse = 1 + Math.sin(game.time * 3) * 0.08;
            const pulsedW = restartBtnW * pulse;
            const pulsedH = restartBtnH * pulse;
            const pulsedX = restartBtnX - (pulsedW - restartBtnW) / 2;
            const pulsedY = restartBtnY - (pulsedH - restartBtnH) / 2;

            // Check hover
            const restartHover = game.mouseX >= pulsedX && game.mouseX <= pulsedX + pulsedW &&
                                 game.mouseY >= pulsedY && game.mouseY <= pulsedY + pulsedH;

            // Glow effect
            if (restartHover) {
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 25;
            }

            const gradient = ctx.createLinearGradient(pulsedX, pulsedY, pulsedX, pulsedY + pulsedH);
            gradient.addColorStop(0, restartHover ? '#66BB6A' : '#81C784');
            gradient.addColorStop(1, restartHover ? '#4CAF50' : '#66BB6A');

            ctx.fillStyle = gradient;
            ctx.strokeStyle = '#1B5E20';
            ctx.lineWidth = 3;
            roundRect(ctx, pulsedX, pulsedY, pulsedW, pulsedH, 10);
            ctx.fill();
            ctx.stroke();

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 24px Caveat, cursive';
            ctx.fillText('Play Again', canvas.width / 2, restartBtnY + 38);

            // Learn More Button
            const learnBtnX = canvas.width / 2 - 100;
            const learnBtnY = canvas.height / 2 + 160;
            const learnBtnW = 200;
            const learnBtnH = 50;

            const learnHover = game.mouseX >= learnBtnX && game.mouseX <= learnBtnX + learnBtnW &&
                               game.mouseY >= learnBtnY && game.mouseY <= learnBtnY + learnBtnH;

            if (learnHover) {
                ctx.shadowColor = '#64B5F6';
                ctx.shadowBlur = 20;
            }

            ctx.fillStyle = learnHover ? 'rgba(100, 181, 246, 0.3)' : 'rgba(255, 255, 255, 0.2)';
            ctx.strokeStyle = '#81C784';
            ctx.lineWidth = 2;
            roundRect(ctx, learnBtnX, learnBtnY, learnBtnW, learnBtnH, 8);
            ctx.fill();
            ctx.stroke();

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 18px Caveat, cursive';
            ctx.fillText('Learn More', canvas.width / 2, learnBtnY + 32);

            // Store button bounds for click detection
            game.victoryRestartBounds = { x: pulsedX, y: pulsedY, w: pulsedW, h: pulsedH };
            game.victoryLearnBounds = { x: learnBtnX, y: learnBtnY, w: learnBtnW, h: learnBtnH };
        }

        function drawGameOverScreen() {
            // Dark overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw skull with zoom and fade animation (moved up 1/5 of canvas height)
            if (game.imagesLoaded && game.images.skull && game.images.skull.complete) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2 - 120; // Moved up 120px (1/5 of 600)
                const skullSize = 300 * game.skullScale;

                ctx.globalAlpha = game.skullAlpha;
                ctx.drawImage(
                    game.images.skull,
                    centerX - skullSize / 2,
                    centerY - skullSize / 2,
                    skullSize,
                    skullSize
                );
                ctx.globalAlpha = 1;
            }

            // Game over text (appears after skull is fully visible)
            if (game.skullAlpha > 0.8) {
                ctx.textAlign = 'center';
                ctx.font = 'bold 50px Caveat, cursive';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 6;
                ctx.fillStyle = '#DC143C';
                ctx.strokeText('GAME OVER', canvas.width / 2, canvas.height / 2 + 80); // Moved up 120px
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 + 80);

                ctx.font = 'bold 24px Caveat, cursive';
                ctx.fillStyle = '#FFF';
                ctx.fillText('All visitors left unhappy...', canvas.width / 2, canvas.height / 2 + 120); // Moved up 120px

                ctx.font = 'bold 18px Caveat, cursive';
                ctx.fillStyle = '#CCC';
                ctx.fillText('Click restart to try again', canvas.width / 2, canvas.height / 2 + 160); // Moved up 120px
            }
        }

        function roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
            const words = text.split(' ');
            let line = '';
            let yPos = y;

            words.forEach((word, i) => {
                const testLine = line + word + ' ';
                const metrics = ctx.measureText(testLine);

                if (metrics.width > maxWidth && i > 0) {
                    ctx.fillText(line, x, yPos);
                    line = word + ' ';
                    yPos += lineHeight;
                } else {
                    line = testLine;
                }
            });
            ctx.fillText(line, x, yPos);
        }

        // Mouse event handlers
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Start screen button
            if (!game.gameStarted && !game.tutorialComplete && !game.tutorialStarted) {
                const btnX = canvas.width / 2 - 100;
                const btnY = canvas.height / 2;
                const btnW = 200;
                const btnH = 60;

                if (x >= btnX && x <= btnX + btnW && y >= btnY && y <= btnY + btnH) {
                    // Start tutorial when button clicked
                    showTutorial();
                }
                return;
            }

            // Tutorial advancement - click anywhere to advance
            if (game.tutorialStarted && !game.tutorialComplete && !game.gameStarted) {
                showTutorial();
                return;
            }

            // Victory screen buttons
            if (game.victoryComplete) {
                // Restart button on victory screen
                if (game.victoryRestartBounds &&
                    x >= game.victoryRestartBounds.x &&
                    x <= game.victoryRestartBounds.x + game.victoryRestartBounds.w &&
                    y >= game.victoryRestartBounds.y &&
                    y <= game.victoryRestartBounds.y + game.victoryRestartBounds.h) {
                    window.location.reload();
                    return;
                }

                // Learn More button on victory screen
                if (game.victoryLearnBounds &&
                    x >= game.victoryLearnBounds.x &&
                    x <= game.victoryLearnBounds.x + game.victoryLearnBounds.w &&
                    y >= game.victoryLearnBounds.y &&
                    y <= game.victoryLearnBounds.y + game.victoryLearnBounds.h) {
                    // Open learn more page
                    alert('This level teaches emergent AI behavior!\n\nIn retail, AI systems learn to optimize environments based on customer feedback - just like you optimized the gallery for visitor happiness.\n\nKey concepts:\n• Environmental sensors (plants, lighting, cleanliness)\n• Visitor behavior patterns (AI pathfinding)\n• Feedback loops (happiness metrics)\n• Emergent optimization (discoveries)\n\nThe thunder cloud represents external factors that help but create challenges - like promotions that drive traffic but require cleanup!');
                    return;
                }
            }

            // Restart button
            if (game.restartButtonCanvasBounds &&
                x >= game.restartButtonCanvasBounds.x &&
                x <= game.restartButtonCanvasBounds.x + game.restartButtonCanvasBounds.w &&
                y >= game.restartButtonCanvasBounds.y &&
                y <= game.restartButtonCanvasBounds.y + game.restartButtonCanvasBounds.h) {
                console.log('Restart clicked!');
                window.location.reload();
                return;
            }

            // Pause handling - click anywhere to resume when paused
            if (game.paused) {
                game.paused = false;
                return;
            }

            // Pause button - only used to pause, not unpause
            if (game.pauseButtonBounds &&
                x >= game.pauseButtonBounds.x &&
                x <= game.pauseButtonBounds.x + game.pauseButtonBounds.w &&
                y >= game.pauseButtonBounds.y &&
                y <= game.pauseButtonBounds.y + game.pauseButtonBounds.h) {
                game.paused = true;
                return;
            }

            if (!game.gameStarted) return;

            // Tool selection buttons
            for (const btn of game.toolButtons) {
                if (x >= btn.x && x <= btn.x + btn.w &&
                    y >= btn.y && y <= btn.y + btn.h) {
                    game.currentTool = btn.tool;
                    return;
                }
            }

            // Tree brightness controls (when light tool selected)
            if (game.currentTool === 'light') {
                const controlX = 20;
                const controlY = 340;

                // Three brightness buttons: Off, Normal, Bright
                for (let b = 0; b < 3; b++) {
                    const btnX = controlX + 5 + (b * 28);
                    const btnY = controlY + 35;
                    const btnW = 25;
                    const btnH = 25;

                    if (x >= btnX && x <= btnX + btnW &&
                        y >= btnY && y <= btnY + btnH) {
                        game.treeBrightness = b;
                        game.lightFlashTimer = 0.5; // Flash effect duration

                        // Spawn particles at tree
                        for (let p = 0; p < 20; p++) {
                            game.particles.push({
                                x: game.branchX + (Math.random() - 0.5) * 100,
                                y: game.branchY + (Math.random() - 0.5) * 100,
                                vy: Math.random() * 2 + 1,
                                size: Math.random() * 4 + 2,
                                alpha: 1,
                                color: '#FFD700'
                            });
                        }
                        return;
                    }
                }
            }

            // Water plants and branch
            if (game.currentTool === 'water') {
                // Check if clicking on branch
                const branchDist = Math.sqrt((game.branchX - x) ** 2 + (game.branchY - y) ** 2);
                if (branchDist < 60) {
                    game.branchWaterLevel += 30;
                    if (game.branchWaterLevel > 100) game.branchWaterLevel = 100;

                    // Spawn water particles
                    for (let i = 0; i < 20; i++) {
                        game.particles.push({
                            x: game.branchX + (Math.random() - 0.5) * 40,
                            y: game.branchY + (Math.random() - 0.5) * 40,
                            vy: Math.random() * 2 + 1,
                            size: Math.random() * 4 + 1,
                            alpha: 1,
                            color: '#2196F3'
                        });
                    }
                    return;
                }

                // Check plants
                for (const plant of game.plants) {
                    const dx = plant.x - x;
                    const dy = plant.y - y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 30) {
                        plant.waterLevel += 30;
                        if (plant.waterLevel > 100) plant.waterLevel = 100;
                        plant.wateringAnimation = 1;

                        // Spawn water particles
                        for (let i = 0; i < 15; i++) {
                            game.particles.push({
                                x: plant.x + (Math.random() - 0.5) * 20,
                                y: plant.y + (Math.random() - 0.5) * 20,
                                vy: Math.random() * 2 + 1,
                                size: Math.random() * 3 + 1,
                                alpha: 1,
                                color: '#2196F3'
                            });
                        }
                        return;
                    }
                }
            }

            // Clean dirt
            if (game.currentTool === 'clean') {
                for (let i = game.dirtSpots.length - 1; i >= 0; i--) {
                    const dirt = game.dirtSpots[i];
                    const dx = dirt.x - x;
                    const dy = dirt.y - y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < dirt.size) {
                        game.dirtSpots.splice(i, 1);

                        // Spawn clean particles
                        for (let p = 0; p < 20; p++) {
                            game.particles.push({
                                x: dirt.x + (Math.random() - 0.5) * 30,
                                y: dirt.y + (Math.random() - 0.5) * 30,
                                vy: Math.random() * 3 + 1,
                                size: Math.random() * 4 + 2,
                                alpha: 1,
                                color: '#4CAF50'
                            });
                        }
                        return;
                    }
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Track mouse position for hover effects
            game.mouseX = x;
            game.mouseY = y;

            // Check start button hover
            if (!game.gameStarted && !game.tutorialComplete) {
                const btnX = canvas.width / 2 - 100;
                const btnY = canvas.height / 2;
                const btnW = 200;
                const btnH = 60;

                game.startButtonHover = (x >= btnX && x <= btnX + btnW && y >= btnY && y <= btnY + btnH);
            }

            // Update cursor based on tool
            if (game.currentTool === 'water') {
                canvas.style.cursor = 'pointer';
            } else if (game.currentTool === 'clean') {
                canvas.style.cursor = 'crosshair';
            } else if (game.currentTool === 'light') {
                canvas.style.cursor = 'pointer';
            } else {
                canvas.style.cursor = 'default';
            }
        });

        // Game loop
        let lastTime = 0;
        function gameLoop(timestamp) {
            const dt = Math.min((timestamp - lastTime) / 1000, 0.1); // Cap dt to avoid huge jumps
            lastTime = timestamp;

            update(dt);
            render();

            requestAnimationFrame(gameLoop);
        }

        // Start
        init();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
