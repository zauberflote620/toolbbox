<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mathematical Optimization Demo - Shop Reset Toolbox</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
        }

        h1 {
            color: #2d3748;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            color: #718096;
            margin-bottom: 30px;
            font-size: 16px;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            align-items: center;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #edf2f7;
            color: #2d3748;
        }

        .btn-secondary:hover {
            background: #e2e8f0;
        }

        .visualization-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .canvas-section {
            background: #f7fafc;
            border-radius: 8px;
            padding: 20px;
        }

        .canvas-section h2 {
            font-size: 18px;
            color: #2d3748;
            margin-bottom: 15px;
        }

        canvas {
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            width: 100%;
            background: white;
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .metric-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.9;
            margin-bottom: 8px;
        }

        .metric-value {
            font-size: 32px;
            font-weight: 700;
        }

        .metric-change {
            font-size: 14px;
            margin-top: 8px;
            opacity: 0.9;
        }

        .metric-change.positive {
            color: #48bb78;
        }

        .metric-change.negative {
            color: #f56565;
        }

        .progress-container {
            background: #f7fafc;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            display: none;
        }

        .progress-container.active {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e2e8f0;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 12px;
        }

        .progress-status {
            color: #4a5568;
            font-size: 14px;
        }

        .objective-details {
            background: #f7fafc;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .objective-details h3 {
            font-size: 18px;
            color: #2d3748;
            margin-bottom: 15px;
        }

        .objective-component {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-bottom: 10px;
            background: white;
            border-radius: 6px;
        }

        .component-name {
            font-weight: 600;
            color: #2d3748;
        }

        .component-weight {
            color: #718096;
            font-size: 14px;
        }

        .component-score {
            font-size: 18px;
            font-weight: 700;
            color: #667eea;
        }

        .algorithm-info {
            background: #edf2f7;
            border-left: 4px solid #667eea;
            padding: 15px 20px;
            margin-bottom: 30px;
        }

        .algorithm-info h4 {
            color: #2d3748;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .algorithm-info p {
            color: #4a5568;
            font-size: 14px;
            line-height: 1.6;
        }

        .legend {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .legend-text {
            font-size: 14px;
            color: #4a5568;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Mathematical Optimization Demo</h1>
        <p class="subtitle">Greedy Heuristic with Local Search - Phase 3 of Shop Reset Toolbox MVP</p>

        <div class="algorithm-info">
            <h4>Algorithm: Greedy Heuristic with Iterative Improvement</h4>
            <p>
                This optimization uses a two-phase approach: (1) Initial greedy placement based on anchor-and-spoke positions,
                and (2) Iterative local search that swaps products between fixtures to maximize the objective function.
                The algorithm terminates when no swap improves the score or maximum iterations are reached.
            </p>
        </div>

        <div class="controls">
            <button class="btn-primary" onclick="runOptimization()" id="optimizeBtn">Run Optimization</button>
            <button class="btn-secondary" onclick="resetLayout()">Reset Layout</button>
            <button class="btn-secondary" onclick="generateRandomProducts()">Generate Random Products</button>
            <select id="productCount" class="btn-secondary">
                <option value="50">50 Products</option>
                <option value="100">100 Products</option>
                <option value="200">200 Products</option>
            </select>
        </div>

        <div class="progress-container" id="progressContainer">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill">0%</div>
            </div>
            <div class="progress-status" id="progressStatus">Initializing optimization...</div>
        </div>

        <div class="metrics">
            <div class="metric-card">
                <div class="metric-label">Objective Score</div>
                <div class="metric-value" id="objectiveScore">0</div>
                <div class="metric-change" id="objectiveChange"></div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Iterations</div>
                <div class="metric-value" id="iterations">0</div>
                <div class="metric-change" id="iterationInfo"></div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Swaps Made</div>
                <div class="metric-value" id="swapsMade">0</div>
                <div class="metric-change" id="swapInfo"></div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Optimization Time</div>
                <div class="metric-value" id="optimizationTime">0s</div>
                <div class="metric-change" id="timeInfo"></div>
            </div>
        </div>

        <div class="objective-details">
            <h3>Objective Function Components</h3>
            <div class="objective-component">
                <div>
                    <span class="component-name">Sales per Square Foot</span>
                    <span class="component-weight"> (Weight: 0.5)</span>
                </div>
                <span class="component-score" id="salesScore">0</span>
            </div>
            <div class="objective-component">
                <div>
                    <span class="component-name">Cross-Sell Opportunities</span>
                    <span class="component-weight"> (Weight: 0.3)</span>
                </div>
                <span class="component-score" id="crossSellScore">0</span>
            </div>
            <div class="objective-component">
                <div>
                    <span class="component-name">Visual Flow Quality</span>
                    <span class="component-weight"> (Weight: 0.2)</span>
                </div>
                <span class="component-score" id="visualFlowScore">0</span>
            </div>
        </div>

        <div class="visualization-container">
            <div class="canvas-section">
                <h2>Before Optimization</h2>
                <canvas id="canvasBefore" width="600" height="450"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f56565;"></div>
                        <span class="legend-text">Low Value Products</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ed8936;"></div>
                        <span class="legend-text">Medium Value Products</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #48bb78;"></div>
                        <span class="legend-text">High Value Products</span>
                    </div>
                </div>
            </div>
            <div class="canvas-section">
                <h2>After Optimization</h2>
                <canvas id="canvasAfter" width="600" height="450"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #667eea;"></div>
                        <span class="legend-text">Fixture Boundary</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ffa500;"></div>
                        <span class="legend-text">Entrance Zone</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== DATA STRUCTURES ====================

        let products = [];
        let fixtures = [];
        let beforeLayout = [];
        let afterLayout = [];
        let currentScore = 0;
        let optimizationWorker = null;

        // Configuration
        const WEIGHTS = {
            salesPerSqFt: 0.5,
            crossSell: 0.3,
            visualFlow: 0.2
        };

        const MAX_ITERATIONS = 1000;
        const IMPROVEMENT_THRESHOLD = 0.01;

        // ==================== PRODUCT GENERATION ====================

        function generateRandomProducts() {
            const count = parseInt(document.getElementById('productCount').value);
            const categories = ['Outerwear', 'Tops', 'Bottoms', 'Footwear', 'Accessories', 'Activewear'];
            const baseNames = {
                'Outerwear': ['Jacket', 'Coat', 'Parka', 'Blazer', 'Vest'],
                'Tops': ['Shirt', 'Sweater', 'Blouse', 'T-Shirt', 'Hoodie'],
                'Bottoms': ['Jeans', 'Pants', 'Shorts', 'Skirt', 'Leggings'],
                'Footwear': ['Boots', 'Sneakers', 'Sandals', 'Heels', 'Loafers'],
                'Accessories': ['Belt', 'Scarf', 'Hat', 'Gloves', 'Bag'],
                'Activewear': ['Yoga Pants', 'Running Shorts', 'Sports Bra', 'Track Jacket', 'Athletic Shoes']
            };

            products = [];

            for (let i = 0; i < count; i++) {
                const category = categories[Math.floor(Math.random() * categories.length)];
                const nameOptions = baseNames[category];
                const name = nameOptions[Math.floor(Math.random() * nameOptions.length)];

                const price = 29.99 + Math.random() * 170;
                const cost = price * (0.3 + Math.random() * 0.3);
                const margin = (price - cost) / price;

                const product = {
                    sku: `PROD-${String(i + 1).padStart(4, '0')}`,
                    name: `${name} ${i + 1}`,
                    category: category,
                    price: parseFloat(price.toFixed(2)),
                    cost: parseFloat(cost.toFixed(2)),
                    margin: parseFloat(margin.toFixed(2)),
                    weight: 0.5 + Math.random() * 4.5,
                    salesVelocity: Math.floor(10 + Math.random() * 90),
                    crossSellWith: [],
                    prominent: Math.random() > 0.85
                };

                products.push(product);
            }

            // Create cross-sell relationships
            products.forEach((product, index) => {
                const numCrossSells = Math.floor(Math.random() * 4);
                const possibleCrossSells = products
                    .filter((p, i) => i !== index && p.category !== product.category)
                    .map(p => p.sku);

                for (let i = 0; i < numCrossSells && possibleCrossSells.length > 0; i++) {
                    const randomIndex = Math.floor(Math.random() * possibleCrossSells.length);
                    product.crossSellWith.push(possibleCrossSells[randomIndex]);
                    possibleCrossSells.splice(randomIndex, 1);
                }
            });

            console.log(`Generated ${count} random products`);
            initializeFixtures();
            createInitialLayout();
            drawCanvas('canvasBefore', beforeLayout);
            updateMetrics(0, 0, 0, 0);
        }

        // ==================== FIXTURE SETUP ====================

        function initializeFixtures() {
            fixtures = [
                { id: 'F1', type: 'Wall Shelf', x: 50, y: 100, width: 200, height: 100, capacity: 500, trafficZone: 'high' },
                { id: 'F2', type: 'Display Table', x: 300, y: 100, width: 150, height: 100, capacity: 300, trafficZone: 'high' },
                { id: 'F3', type: 'Shelf Unit', x: 50, y: 250, width: 200, height: 100, capacity: 500, trafficZone: 'medium' },
                { id: 'F4', type: 'Endcap', x: 300, y: 250, width: 150, height: 100, capacity: 200, trafficZone: 'medium' },
                { id: 'F5', type: 'Back Wall', x: 500, y: 100, width: 80, height: 250, capacity: 400, trafficZone: 'low' }
            ];
        }

        // ==================== LAYOUT MANAGEMENT ====================

        function createInitialLayout() {
            beforeLayout = [];

            // Distribute products across fixtures randomly
            let fixtureIndex = 0;
            products.forEach((product) => {
                const fixture = fixtures[fixtureIndex];
                beforeLayout.push({
                    product: product,
                    fixtureId: fixture.id
                });
                fixtureIndex = (fixtureIndex + 1) % fixtures.length;
            });

            afterLayout = JSON.parse(JSON.stringify(beforeLayout));
        }

        // ==================== OBJECTIVE FUNCTION ====================

        function calculateObjectiveFunction(layout) {
            let salesScore = calculateSalesPerSqFt(layout);
            let crossSellScore = calculateCrossSellOpportunities(layout);
            let visualFlowScore = calculateVisualFlow(layout);

            const totalScore =
                (salesScore * WEIGHTS.salesPerSqFt) +
                (crossSellScore * WEIGHTS.crossSell) +
                (visualFlowScore * WEIGHTS.visualFlow);

            return {
                total: totalScore,
                sales: salesScore,
                crossSell: crossSellScore,
                visualFlow: visualFlowScore
            };
        }

        function calculateSalesPerSqFt(layout) {
            let score = 0;

            fixtures.forEach(fixture => {
                const fixtureProducts = layout.filter(item => item.fixtureId === fixture.id);
                const fixtureArea = (fixture.width * fixture.height) / 100;

                let totalValue = 0;
                fixtureProducts.forEach(item => {
                    const productValue = item.product.price * item.product.margin * item.product.salesVelocity;

                    // High-traffic zones get bonus
                    let trafficMultiplier = 1.0;
                    if (fixture.trafficZone === 'high') trafficMultiplier = 1.5;
                    else if (fixture.trafficZone === 'medium') trafficMultiplier = 1.2;

                    totalValue += productValue * trafficMultiplier;
                });

                score += totalValue / fixtureArea;
            });

            return score;
        }

        function calculateCrossSellOpportunities(layout) {
            let score = 0;

            layout.forEach(item1 => {
                const fixture1 = fixtures.find(f => f.id === item1.fixtureId);

                item1.product.crossSellWith.forEach(crossSellSku => {
                    const item2 = layout.find(item => item.product.sku === crossSellSku);
                    if (!item2) return;

                    const fixture2 = fixtures.find(f => f.id === item2.fixtureId);

                    // Calculate distance between fixtures
                    const dx = fixture1.x - fixture2.x;
                    const dy = fixture1.y - fixture2.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // Closer cross-sell products get higher score
                    if (distance < 100) score += 100;
                    else if (distance < 200) score += 50;
                    else if (distance < 300) score += 20;
                });
            });

            return score;
        }

        function calculateVisualFlow(layout) {
            let score = 100;

            // Check if high-value products are near entrance
            const entranceFixtures = fixtures.filter(f => f.trafficZone === 'high');

            entranceFixtures.forEach(fixture => {
                const fixtureProducts = layout.filter(item => item.fixtureId === fixture.id);
                const highValueProducts = fixtureProducts.filter(item =>
                    item.product.margin > 0.4 && item.product.salesVelocity > 50
                );

                const ratio = highValueProducts.length / (fixtureProducts.length || 1);
                score += ratio * 100;
            });

            // Check for product variety distribution
            const categoriesPerFixture = {};
            fixtures.forEach(fixture => {
                const fixtureProducts = layout.filter(item => item.fixtureId === fixture.id);
                const categories = new Set(fixtureProducts.map(item => item.product.category));
                categoriesPerFixture[fixture.id] = categories.size;
            });

            const avgCategories = Object.values(categoriesPerFixture).reduce((a, b) => a + b, 0) / fixtures.length;
            score += avgCategories * 20;

            return score;
        }

        // ==================== OPTIMIZATION ALGORITHM ====================

        function runOptimization() {
            // Show progress container
            document.getElementById('progressContainer').classList.add('active');
            document.getElementById('optimizeBtn').disabled = true;

            // Use Web Worker for products > 75, otherwise run in main thread
            const useWorker = products.length > 75;

            if (useWorker) {
                runOptimizationWithWorker();
            } else {
                runOptimizationMainThread();
            }
        }

        function runOptimizationWithWorker() {
            // Create Web Worker
            const worker = new Worker('optimization-worker.js');

            worker.onmessage = function(e) {
                const { type, progress, iteration, currentScore, result, message } = e.data;

                if (type === 'PROGRESS') {
                    updateProgress(progress, `Iteration ${iteration} (Score: ${Math.round(currentScore)})`);
                } else if (type === 'COMPLETE') {
                    handleOptimizationComplete(result);
                    worker.terminate();
                } else if (type === 'LOG') {
                    console.log('Worker:', message);
                }
            };

            worker.onerror = function(error) {
                console.error('Worker error:', error);
                document.getElementById('progressContainer').classList.remove('active');
                document.getElementById('optimizeBtn').disabled = false;
                alert('Optimization failed. Please try again.');
            };

            // Send optimization request to worker
            worker.postMessage({
                type: 'OPTIMIZE',
                data: {
                    products: products,
                    fixtures: fixtures,
                    layout: beforeLayout,
                    maxIterations: MAX_ITERATIONS
                }
            });
        }

        function runOptimizationMainThread() {
            const startTime = Date.now();

            let iterations = 0;
            let swapsMade = 0;
            let currentLayout = JSON.parse(JSON.stringify(beforeLayout));
            let currentObjective = calculateObjectiveFunction(currentLayout);
            let bestLayout = currentLayout;
            let bestObjective = currentObjective;

            console.log('Initial objective:', currentObjective.total);

            let improved = true;

            while (improved && iterations < MAX_ITERATIONS) {
                improved = false;
                iterations++;

                const progress = Math.min((iterations / MAX_ITERATIONS) * 100, 100);
                updateProgress(progress, `Iteration ${iterations} of ${MAX_ITERATIONS}`);

                for (let i = 0; i < currentLayout.length - 1; i++) {
                    for (let j = i + 1; j < currentLayout.length; j++) {
                        if (currentLayout[i].fixtureId === currentLayout[j].fixtureId) continue;

                        const trialLayout = JSON.parse(JSON.stringify(currentLayout));
                        const tempFixture = trialLayout[i].fixtureId;
                        trialLayout[i].fixtureId = trialLayout[j].fixtureId;
                        trialLayout[j].fixtureId = tempFixture;

                        if (!meetsConstraints(trialLayout)) continue;

                        const trialObjective = calculateObjectiveFunction(trialLayout);

                        if (trialObjective.total > currentObjective.total + IMPROVEMENT_THRESHOLD) {
                            currentLayout = trialLayout;
                            currentObjective = trialObjective;
                            swapsMade++;
                            improved = true;

                            if (currentObjective.total > bestObjective.total) {
                                bestLayout = currentLayout;
                                bestObjective = currentObjective;
                            }
                        }
                    }
                }

                if (!improved) break;
            }

            const endTime = Date.now();
            const duration = (endTime - startTime) / 1000;

            handleOptimizationComplete({
                layout: bestLayout,
                objective: bestObjective,
                iterations: iterations,
                swapsMade: swapsMade,
                duration: duration
            });
        }

        function handleOptimizationComplete(result) {
            const { layout, objective, iterations, swapsMade, duration } = result;

            console.log('Optimization complete');
            console.log('Final objective:', objective.total);
            console.log('Iterations:', iterations);
            console.log('Swaps made:', swapsMade);
            console.log('Duration:', duration.toFixed(2), 's');

            afterLayout = layout;
            drawCanvas('canvasAfter', afterLayout);

            const initialObjective = calculateObjectiveFunction(beforeLayout);
            const improvement = ((objective.total - initialObjective.total) / initialObjective.total * 100).toFixed(1);

            updateMetrics(objective.total, iterations, swapsMade, duration.toFixed(2));
            updateObjectiveDetails(objective);

            const changeElement = document.getElementById('objectiveChange');
            changeElement.textContent = `+${improvement}% improvement`;
            changeElement.className = 'metric-change positive';

            setTimeout(() => {
                document.getElementById('progressContainer').classList.remove('active');
                document.getElementById('optimizeBtn').disabled = false;
            }, 500);
        }

        // ==================== CONSTRAINT VALIDATION ====================

        function meetsConstraints(layout) {
            // Check fixture weight capacity
            for (let fixture of fixtures) {
                const fixtureProducts = layout.filter(item => item.fixtureId === fixture.id);
                const totalWeight = fixtureProducts.reduce((sum, item) => sum + item.product.weight, 0);

                if (totalWeight > fixture.capacity) {
                    return false;
                }
            }

            return true;
        }

        // ==================== VISUALIZATION ====================

        function drawCanvas(canvasId, layout) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw entrance
            ctx.fillStyle = '#ffa500';
            ctx.globalAlpha = 0.2;
            ctx.fillRect(0, 0, 100, 50);
            ctx.globalAlpha = 1.0;
            ctx.strokeStyle = '#ffa500';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, 100, 50);
            ctx.fillStyle = '#2d3748';
            ctx.font = '12px Arial';
            ctx.fillText('Entrance', 20, 30);

            // Draw fixtures
            fixtures.forEach(fixture => {
                // Fixture rectangle
                ctx.fillStyle = '#edf2f7';
                ctx.fillRect(fixture.x, fixture.y, fixture.width, fixture.height);
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.strokeRect(fixture.x, fixture.y, fixture.width, fixture.height);

                // Fixture label
                ctx.fillStyle = '#2d3748';
                ctx.font = 'bold 12px Arial';
                ctx.fillText(fixture.id, fixture.x + 5, fixture.y + 15);
                ctx.font = '10px Arial';
                ctx.fillText(fixture.type, fixture.x + 5, fixture.y + 28);

                // Draw products in this fixture
                const fixtureProducts = layout.filter(item => item.fixtureId === fixture.id);
                const productsToShow = Math.min(fixtureProducts.length, 10);

                for (let i = 0; i < productsToShow; i++) {
                    const product = fixtureProducts[i].product;

                    // Determine color based on value
                    const productValue = product.price * product.margin * product.salesVelocity;
                    let color = '#f56565'; // Low value - red
                    if (productValue > 5000) color = '#48bb78'; // High value - green
                    else if (productValue > 2000) color = '#ed8936'; // Medium value - orange

                    const size = 8;
                    const cols = 5;
                    const offsetX = (i % cols) * 15 + 10;
                    const offsetY = Math.floor(i / cols) * 15 + 45;

                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(fixture.x + offsetX, fixture.y + offsetY, size, 0, 2 * Math.PI);
                    ctx.fill();
                }

                // Show count if more products
                if (fixtureProducts.length > 10) {
                    ctx.fillStyle = '#4a5568';
                    ctx.font = '10px Arial';
                    ctx.fillText(`+${fixtureProducts.length - 10} more`, fixture.x + 10, fixture.y + fixture.height - 10);
                }
            });
        }

        // ==================== UI UPDATES ====================

        function updateProgress(percent, status) {
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressFill').textContent = Math.round(percent) + '%';
            document.getElementById('progressStatus').textContent = status;
        }

        function updateMetrics(score, iterations, swaps, time) {
            document.getElementById('objectiveScore').textContent = Math.round(score);
            document.getElementById('iterations').textContent = iterations;
            document.getElementById('swapsMade').textContent = swaps;
            document.getElementById('optimizationTime').textContent = time + 's';
        }

        function updateObjectiveDetails(objective) {
            document.getElementById('salesScore').textContent = Math.round(objective.sales);
            document.getElementById('crossSellScore').textContent = Math.round(objective.crossSell);
            document.getElementById('visualFlowScore').textContent = Math.round(objective.visualFlow);
        }

        function resetLayout() {
            createInitialLayout();
            drawCanvas('canvasBefore', beforeLayout);
            drawCanvas('canvasAfter', afterLayout);
            updateMetrics(0, 0, 0, 0);
            updateObjectiveDetails({ sales: 0, crossSell: 0, visualFlow: 0 });
            document.getElementById('objectiveChange').textContent = '';
        }

        // ==================== INITIALIZATION ====================

        window.addEventListener('load', () => {
            console.log('Mathematical Optimization Demo Loaded');
            generateRandomProducts();
        });
    </script>
</body>
</html>
